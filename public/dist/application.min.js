'use strict';

// Init the application configuration module for AngularJS application
var ApplicationConfiguration = (function() {
    // Init module configuration options
    var applicationModuleName = 'apollo';
    var applicationModuleVendorDependencies = [
        'ngResource',
        'ngCookies',
        'ngAnimate',
        'ngTouch',
        'ngSanitize',
        'ui.router',
        'ui.bootstrap',
        'ui.utils',
        'ngAutocomplete',
        'LocalStorageModule',
        'angularMoment',
        'angularFileUpload',
        'angularMoment',
        'gettext',
        'btford.socket-io',
        'angularPayments',
        'meta',
        'angular-google-analytics',
        'seo'
    ];

    // Add a new vertical module
    var registerModule = function(moduleName) {
        // Create angular module
        angular.module(moduleName, []);

        // Add the module to the AngularJS configuration file
        angular.module(applicationModuleName).requires.push(moduleName);
    };

    return {
        applicationModuleName: applicationModuleName,
        applicationModuleVendorDependencies: applicationModuleVendorDependencies,
        registerModule: registerModule
    };
})();

'use strict';

//Start by defining the main module and adding the module dependencies
angular.module(ApplicationConfiguration.applicationModuleName, ApplicationConfiguration.applicationModuleVendorDependencies);

// Setting HTML5 Location Mode
angular.module(ApplicationConfiguration.applicationModuleName).config(['$locationProvider',
    function($locationProvider) {
        // Enable html5 pushstate
        $locationProvider.html5Mode(true);

        // $locationProvider.hashPrefix('!');
    }
]);

//Then define the init function for starting up the application
angular.element(document).ready(function() {
    //Fixing facebook bug with redirect
    // if (window.location.hash === '#_=_') window.location.hash = '';
    // -> breaks angular 1.3 ...

    //Then init the app
    angular.bootstrap(document, [ApplicationConfiguration.applicationModuleName]);
});

angular.module('gettext').run(['gettextCatalog', function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings('en', {"/ Maand":"/ Month","1ROOF maakt je leven makkelijker.":"1ROOF makes your life easier.","1Roof is een website met een missie om voor jou alles makkelijker te maken. We streven ernaar om je op de simpelste manier dichterbij te brengen bij het pand van je dromen.":"1Roof is a website with a mission to make everything easier for you. We are committed to bring you closer to the simplest to find the place of your dreams.","<h2 class=\"empty-icon text-center\"><i class=\"icon-home-1\"></i></h2>\n                <p class=\"lead text-center\" translate=\"\">Geen resultaten gevonden. Probeer minder filters te gebruiken of zoom uit op de kaart.</p>":"<h2 class=\"empty-icon text-center\"><i class=\"icon-home-1\"></i></h2>\n                <p class=\"lead text-center\" translate=\"\">No results found. Try using less filters or zoom out of the map.</p>","Aanbieden.":"Add a space.","Aanpassen":"Modify","Achternaam":"Last name","Adres":"Address","Adres aanpassen":"Edit address","Adres van de ruimte":"Address of the premises","Adverteer je ruimte":"Advertise your space","Advertentie aanpassen":"Modify advertisement","Advertentie niet gevonden":"Advertisement not found","Afbeeldingen":"Images","Afbeeldingen toevoegen":"Add images","Afspraak maken":"Make appointment","Afspraken.":"Appointments.","Agentschap":"Agency","Algemeen":"General","Algemene informatie over de ruimte":"General information","Alle":"All","Alle rechten voorbehouden.":"All rights reserved.","Analytics":"Analytics","Antwerpen":"Antwerp","Aparte badkamer":"Seperate bathroom","Aparte keuken":"Seperate kitchen","App.":"App.","Appartement":"Appartment","Auto garage":"Garage","Basis kosten":"Base costs","Basis prijs":"Base price","Bekijk deze ruimte":"View this room","Bericht versturen":"Send message","Berichten":"Messages","Beschikbaar van":"Available from","Beschikbaarheid":"Availability","Beschikbare voorzieningen":"Available amenities","Beschrijving":"Description","Bijgewerkt":"Modified","Brussel":"Brussels","Chat met je huisbaas":"Chat with your landlord","Chatten.":"Chat.","Contact":"Contact","Contacteer ons!":"Contact us!","Contactpersoon":"Contact","Contract":"Contract","Delen":"Share","Deze persoon heeft nog geen advertenties in zijn wishlist geplaatst":"No ads in this wishlist","Domicilie verplicht":"Domicile required","Driemaandelijks":"Quarterly","Dubbel glas":"Double glass","Elke aanpassing die je maakt, wordt automatisch opgeslaan. Begin met een duidelijke titel.":"Every change you make is automatically saved. Start with a good title.","Email verzonden. Hou je inbox in de gaten.":"Email sent. Keep an eye on your inbox.","Er is iets misgelopen met het updaten van je tariefplan, probeer later opnieuw.":"Something went wrong with updating your subscription, please try again later.","Er was een probleem bij het toevoegen aan je favorieten, probeer later eens opnieuw.":"There was a problem adding it to your favorites, please try again later.","Er was een probleem bij het toevoegen van de afbeelding, probeer later eens opnieuw.":"There was a problem adding the image, try again later.","Er was een probleem met het verzenden van je bericht, probeer later eens opnieuw.":"There was a problem sending your message, please try again later.","Extra kosten":"Extra costs","Facturatie periode":"Billing period","Favorieten":"Favorites","Fietsstalling":"Bike shed","Foto uploaden":"Upload image","Ga verder":"Continue","Gas, elektriciteit en water (optioneel)":"Gas, electricity and water (optional)","Geef een duidelijke beschrijving over je ruimte":"Type a clear description of the ad","Geef een gepaste titel in":"Type a good title","Geef het adres in":"Type in the address","Geen resultaten gevonden. Probeer minder filters te gebruiken of zoom uit op de kaart.":"No results found. Try fewer filters or zoom out on the map.","Gemeubeld":"Furnished","Gent":"Ghent","Hasselt":"Hasselt","Heb je al een account?":"Already have an account?","Heb je een vraag, zit je met iets of wil je gewoon iets kwijt? Aarzel dan niet om ons te contacteren.":"Have a question, wondering about something or just want to say something? Please do not hesitate to contact us.","Home":"Home","Huis":"House","Huisbaas":"Landlord","Huisdieren toegelaten":"Pets allowed","Hulp nodig?":"Need help?","Ik heb al een account":"I already have an account","Ik zoek een huisgenoot":"I'm looking for a roommate","Impressies":"Impressions","In welke periode is deze ruimte beschikbaar?":"In what period is this room available?","Inloggen":"Log in","Internet":"Internet","Items met een waarschuwing moet je oplossen voor je je advertentie online kan plaatsen.":"Items with a warning must be solved before you can place your ad online .","Jaarlijks":"Yearly","Je bericht is verzonden!":"Your message is sent!","Je droomhuis nog niet kunnen vinden? Geen nood, we kunnen je een email sturen als er een advertentie wordt geplaatst die aan jouw criteria voldoet.":"Haven't found your dreamhouse yet? Do not worry, we can send you an email when an advertisement is placed that matches your criteria.","Je kan deze advertentie online plaatsen":"You can place this ad online","Je moet een huisnummer ingeven":"You need to type a streetnumber","Je moet een straat intypen":"You need to type in an address","Je moet meer details ingeven":"You have to add more details","Je tariefplan is geupdatet!":"Your subscription has been updated!","Je wachtwoord is met succes aangepast.":"Password successfully changed.","Je wachtwoord vergeten?":"Forgot password?","Kamer":"Room","Kiezen van Dropbox":"Choose from Dropbox","Klaar om contact op te nemen met de eigenaar?":"Ready to contact the owner?","Kortrijk":"Kortrijk","Kosten":"Costs","Krijg meldingen":"Get alerts","Laatst bijgewerkt {{room.updated | amDateFormat:'ll'}}":"Last modified {{room.updated | amDateFormat:'ll'}}","Laatste online":"Latest online","Leuven":"Leuven","Maak een account aan":"Create an account","Maak een afspraak":"Make an appointment","Maandelijks":"Monthly","Maximum 8 afbeeldingen per ruimte":"Maximum 8 pictures per space","Met amper twee klikken kan je een afspraak maken met een huisbaas. Geen tijd te verliezen!":"With just two clicks you can make an appointment with a landlord. No time to lose!","Met hoeveel mensen wil je samenwonen?":"With how many others do you want to live together?","Met slechts enkele klikken kan je je advertentie onlne plaatsen.":"You can place this ad online","Mijn advertenties":"My advertisements","Mijn profiel":"My profile","Mijn wishlist":"My wishlist","Misbruik melden":"Report abuse","Neem contact op":"Contact us","Nieuw wachtwoord":"New password","Nieuw wachtwoord aanvragen":"Get new password","Nieuwe account":"New account","Nog geen data beschikbaar":"No data available","Onmiddelijk beschikbaar":"Available immediately","Onmiddelijk beschikbaar!":"Available immediately!","Ontdek prachtige accomodaties overal in België":"Discover beautiful homes everywhere in Belgium","Oppervlakte":"Surface","Oppervlakte in m&sup2;":"Surface in m&sup2;","Oppervlakte in m²":"Surface in m²","Over ons":"About us","Populaire steden":"Popular cities","Praat en stel vragen met de huisbazen alsof ze naast jou zaten. Krijg vliegensvlug een antwoord.":"Chat and ask questions with the landlords as if they were sitting next to you. Get an answer on the fly.","Profiel aanpassen":"Edit profile","Registreren":"Register","Samenwonen":"Cohabit","Schoonmaak (optioneel)":"Cleaning (optional)","Schoonmaak kosten":"Cleaning costs","Snel. Simpel. Gemakkelijk.":"Fast. Simple. Easy.","Stap 1: meld je aan":"Step 1: log in","Stap 2: maak een advertentie":"Step 2: create your ad","Stap 3: pas ze aan":"Step 3: modify it","Student":"Student","Stuur een bericht":"Send a message","TV":"TV","Terras":"Terrace","Terug naar kaart":"Back to map","Titel <i class=\"icon-info-circled\" tooltip=\"Gebruik voor de titel enkele kernwoorden die onmiddelijk je advertentie beschrijven. Je kan in de beschrijving meer uitleg geven.\"></i>":"Title <i class=\"icon-info-circled\" tooltip=\"Choose some good keywords for the title.\"></i>","Toegevoegd aan favorieten!":"Added to favorites!","Typ je bericht":"Type your message","Typ je wachtwoord opnieuw":"Type your password again","Type ruimte":"Room type","Type wachtwoord opnieuw":"Type your password again","Uitloggen":"Log out","Upgraden":"Upgrade","Verwijder deze advertentie":"Remove this ad","Verzend":"Send","Volledig huis":"House","Voornaam":"First name","Voorzieningen":"Ameneties","Vragen over deze ruimte?":"Questions about this ad?","Vul je email in":"Enter your email","Waar wil je iets huren?":"Where do you want to rent something?","Wachtwoord":"Password","Wachtwoord opnieuw instellen":"Reset password","Wachtwoord vergeten?":"Forgot password?","Wie zijn we":"Who we are","Zoeken":"Search","Zoekopdracht verfijnen":"Refine search","aantal keer bekeken per dag":"views per day","andere(n) in dit pand":"other(s) in this premises","bekijk de advertentie":"view this ad","hou me op de hoogte van nieuwe aanbiedingen":"keep me informed of new offers","huurcontract":"lease","of":"of","onderverhuring":"sublease","opgeslaan":"saved","per drie maand":"quarterly","per jaar":"per year","per maand":"per month","tot":"till","totaal aantal favorieten per dag":"total amount of favorites per day","van":"of","voorbeeld@email.com":"example@email.com","voorbeeld@gmail.com":"example@gmail.com","wachtwoord":"password","zoekt huisgenoot":"looking for roommate","{{::otherRooms.length}} andere ruimte(n) in deze woning":"{{::otherRooms.length}} other rooms in this house","{{results.length}} advertentie(s) gevonden":"{{results.length}} ads found","{{room.pictures.length}} foto's":"{{room.pictures.length}} pictures","Meer over ons":"More about us","Meldingen.":"Notifications.","appartement":"appartment","huis":"house","kantoor":"office","kot":"room","villa":"villa","woning":"home","Meer info":"More info","Foto's zijn het eerste waar iemand op let. Zorg er voor dus dat je veel en duidelijke foto's hebt! Op deze manier zal je advertentie veel sneller verhuurd worden!":"Photos are the first thing that someone pays attention to. Make sure that you have alot clear images! This way your ad will be leased much faster!","Ga":"Go","Meer informatie":"More information","Titel":"Title"});
/* jshint +W100 */
}]);
'use strict';

// Use Applicaion configuration module to register a new module
ApplicationConfiguration.registerModule('core');

'use strict';

// Use application configuration module to register a new module
ApplicationConfiguration.registerModule('promote');

'use strict';

// Use applicaion configuration module to register a new module
ApplicationConfiguration.registerModule('rooms');
'use strict';

// Use applicaion configuration module to register a new module
ApplicationConfiguration.registerModule('search');

'use strict';

// Use Applicaion configuration module to register a new module
ApplicationConfiguration.registerModule('users');

'use strict';

// Setting up route
angular.module('core').config(['AnalyticsProvider',
    function(AnalyticsProvider) {
        AnalyticsProvider.setAccount('UA-54653288-1');

        AnalyticsProvider.trackPages(true);

        AnalyticsProvider.useAnalytics(true);

        AnalyticsProvider.setPageEvent('$stateChangeSuccess');
    }
]).run(['Meta',
    function(Meta) {
        Meta.init();
    }
]);

'use strict';

// Setting up route
angular.module('core').config([ 'MetaProvider',
    function(MetaProvider) {
        MetaProvider
          .when('/about', {
            title: 'Over ons'
          })

          .otherwise({
            title: '1Roof - Vind je nieuwe woonst',
            description: 'Zoek tussen alle huurwoningen in België. Vind de panden met beste prijs/kwaliteit. Zie echte fotos van oplijstingen.',
            image: '/modules/core/img/brand/logo_big.png'
          });
    }
]);

'use strict';

// Setting up route
angular.module('core').config(['$stateProvider', '$urlRouterProvider',
    function($stateProvider, $urlRouterProvider) {
        // Redirect to home view when route not found
        $urlRouterProvider.otherwise('/');

        // Home state routing
        $stateProvider.
        state('home', {
            url: '/',
            templateUrl: '/modules/core/views/home.client.view.html'
        }).
        // state('comingsoon', {
        //     url: '/',
        //     templateUrl: '/modules/core/views/comingsoon.client.view.html'
        // }).
        state('pricing', {
            url: '/pricing?coupon',
            params: {
                message: {
                    value: null
                },
                coupon: {
                    value: null
                }
            },
            templateUrl: '/modules/core/views/pricing.client.view.html'
        }).
        state('about', {
            url: '/about',
            templateUrl: '/modules/core/views/about.client.view.html'
        });
    }
]);

'use strict';

angular.module('core').controller('FooterController', ['$scope', '$rootScope', 'Rooms',
    function($scope, $rootScope, Rooms) {
        $scope.hidden = false;

        $rootScope.$on('hide_footer', function(event) {
            $scope.hidden = true;
        });

        $scope.init = function() {
        	$scope.latestRooms = Rooms.getLatestRooms({ limit: 4 });
        };

        $scope.getImageLink = function(picture) {
        	var url = '';

            if (picture.provider === 'cloudinary')
                url = 'https://res.cloudinary.com/dv8yfamzc/image/upload/w_200,h_200,c_fill/' + picture.link + '.png';
            else url = picture.link;

            return url;
        };

        $scope.getCurrentYear = function() {
            return new Date().getFullYear();
        };
    }
]);

'use strict';

angular.module('core').controller('HeaderController', ['$rootScope', '$scope', '$stateParams', '$location', '$modal', '$http', '$interval', 'Authentication', 'Geocoder', 'Modal', 'gettextCatalog', 'Socket', 'amMoment', '$state', 'Analytics', 'localStorageService',
    function($rootScope, $scope, $stateParams, $location, $modal, $http, $interval, Authentication, Geocoder, Modal, gettextCatalog, Socket, amMoment, $state, Analytics, localStorageService) {
        $scope.authentication = Authentication;

        $scope.isCollapsed = true;
        $scope.unreadMessageCount = 0;

        $scope.search = {
            input: '',
            details: {},
            autocompleteOptions: { types: '(cities)', country: 'be' }
        };
        
        $scope.init = function() {
            $scope.isHomepage = document.location.pathname === '/';

            var savedLanguage = localStorageService.get('language');
            if (savedLanguage) {
                $rootScope.language = savedLanguage;
                setLanguage(savedLanguage, false);
            } else {
                $rootScope.language = 'nl';
                setLanguage('nl', false);
            }

            // detect browser language
            // $rootScope.language = (window.navigator.userLanguage || window.navigator.language).split('-')[0];
            // if ($rootScope.language.indexOf('nl') !== -1) setLanguage('nl', false);
            // else setLanguage('en', true);
            // watch for language changes
            $rootScope.$watch('language', function(newVal, oldVal) {
                if (newVal !== oldVal) setLanguage(newVal, true);
            });

            // always close the menu after navigating
            $rootScope.$on('$locationChangeSuccess', function() {
                $scope.isCollapsed = true;
                $scope.isHomepage = document.location.pathname === '/';
            });
            // re-initialize sockets on log in
            $rootScope.$on('logged_in', function() {
                initializeSocket();
            });

            initializeSocket();
        };

        $scope.toggleCollapsibleMenu = function() {
            $scope.isCollapsed = !$scope.isCollapsed;
        };

        $scope.goToSearch = function() {
            if ($scope.search.details.geometry) {
                changeLocation(
                    $scope.search.input.replace(/, /g, '--'),
                    $scope.search.details.geometry.location.lat(),
                    $scope.search.details.geometry.location.lng()
                );
            } else {
                Geocoder.geocodeAddress($scope.search.input).then(function(result) {
                    changeLocation(result.formattedAddress.replace(/, /g, '--'), result.lat, result.lng);
                });
            }
            
        };

        $scope.openSignupModal = function() {
            Modal.signup();
        };

        $scope.openSigninModal = function() {
            Modal.signin();
        };

        $scope.getUnreadMessageCount = function() {
            if (Authentication.user) {
                $http({
                    method: 'GET',
                    url: '/api/users/unreadmessages'
                }).then(function(result) {
                    $scope.unreadMessageCount = result.data;
                });
            }
        };

        function initializeSocket() {
            // subscribe to new messages
            if (Authentication.user) {
                Socket.emit('join', Authentication.user._id);
                Socket.on('newMessageCount', function(response) {
                    if (!$stateParams.inboxId || $stateParams.inboxId !== response.inbox) {
                        $scope.unreadMessageCount = +$scope.unreadMessageCount + response.count;
                        if ( $scope.unreadMessageCount < 0)  $scope.unreadMessageCount = 0;

                        playNewMessageSound();
                    }
                });

                $rootScope.$on('inbox_read', function(event, count) {
                    if (count > 0) $scope.unreadMessageCount -= count;
                });
            }
        }

        function playNewMessageSound() {
            var audio = new Audio('/modules/core/img/woosh.wav');
            audio.play();
        }

        function changeLocation(address, lat, lng) {
            $scope.search.input = '';
            $scope.search.details = {};
            
            $location.path('/search/' + address)
                .search('lat', lat)
                .search('lng', lng)
                .search('proximity', 3600);
        }

        function setLanguage(language, reload) {
            // TODO: save language in localStorage
            console.log('changing language to %s', language);

            // gettext
            gettextCatalog.setCurrentLanguage(language);
            // gettextCatalog.debug = true;

            // momentjs
            amMoment.changeLocale(language);

            localStorageService.set('language', language);

            if (reload)
                $state.reload();
        }
    }
]);

'use strict';

angular.module('core').controller('HomeController', ['$scope', '$location', 'Authentication', 'Geocoder', 'Alert',
    function($scope, $location, Authentication, Geocoder, Alert) {
        $scope.authentication = Authentication;

        $scope.search = {
            input: '',
            details: {},
            autocompleteOptions: { types: '(cities)', country: 'be' }
        };

        $scope.init = function() {
            $scope.htmlReady(); 
        };

        $scope.goToSearch = function() {
            if ($scope.search.details.geometry) {
                changeLocation(
                    $scope.search.input.replace(/, /g, '--'),
                    $scope.search.details.geometry.location.lat(),
                    $scope.search.details.geometry.location.lng()
                );
            } else {
                Geocoder.geocodeAddress($scope.search.input).then(function(result) {
                    changeLocation(result.formattedAddress.replace(/, /g, '--'), result.lat, result.lng);
                });
            }
            $scope.search.details = {};
        };

        function changeLocation(address, lat, lng) {
            $location.path('search/' + address)
                .search('lat', lat)
                .search('lng', lng)
                .search('proximity', 3600);
        }

    }
]);

'use strict';

// Rooms controller
angular.module('rooms').controller('ModalPaymentController', ['$rootScope', '$scope', '$http', '$modalInstance', 'options', 'Alert', 'Analytics', 'gettext',
    function($rootScope, $scope, $http, $modalInstance, options, Alert, Analytics, gettext) {
        $scope.subscriptionPlan = options.plan;

        $scope.busy = false;

        $scope.submitPayment = function(status, response) {
            $scope.busy = true;

            if (response.error) {
                // there was an error
                $scope.busy = false;
                Alert.add('danger', gettext('Er is iets misgelopen met het updaten van je tariefplan, probeer later opnieuw.'), 5000);
            } else {
                // got stripe token, now charge it
                saveSubscription(options.plan, response.id, options.couponCode);
            }
        };

        function saveSubscription(plan, card, couponCode) {
            $http.post('/api/subscription/choose', {
                plan: plan,
                card: card,
                couponCode: couponCode
            }).success(function(response) {
                $modalInstance.close(response);
                $scope.busy = false;

                Analytics.trackEvent('Subscription', 'Changed', plan, couponCode);
            }).error(function(response) {
                $scope.busy = false;
                $modalInstance.dismiss({
                    error: true
                });
            });
        }

    }
]);

'use strict';

angular.module('core').controller('PricingController', ['$scope', '$location', '$stateParams', 'Authentication', 'Alert', '$http', 'Modal', 'Enforcer', 'Analytics', 'gettext',
    function($scope, $location, $stateParams, Authentication, Alert, $http, Modal, Enforcer, Analytics, gettext) {
        $scope.authentication = Authentication;

        $scope.busy = false;

        var coupon = null;

        $scope.init = function() {
            $scope.message = $stateParams.message;
            coupon = $stateParams.coupon;

            $scope.htmlReady(); 
        };

        $scope.choosePlan = function(plan) {
            $scope.busy = true;

            Enforcer.do(function() {
                if (Authentication.user && !Authentication.user.subscription.customerToken) {
                    Modal.payment({
                        plan: plan,
                        couponCode: coupon
                    }).then(function(response) {
                        Authentication.user = response;
                        Alert.add('success', gettext('Je tariefplan is geupdatet!'), 5000);
                        $scope.busy = false;
                    }, function(result) {
                        if (result && result.error) {
                            Alert.add('danger', gettext('Er is iets misgelopen met het updaten van je tariefplan, probeer later opnieuw.'), 5000);
                        }
                        $scope.busy = false;
                    });
                } else {
                    saveSubscription(plan, coupon);
                }
            });
        };

        $scope.isCurrentPlan = function(plan) {
            if (Authentication.user) return Authentication.user.subscription.plan === plan;
            else return false;
        };

        function setCurrentPlan(plan) {
            Authentication.user.subscription.plan = plan;
        }

        function saveSubscription(plan, couponCode) {
            $http.post('/api/subscription/choose', {
                plan: plan,
                couponCode: couponCode
            }).success(function(response) {
                Authentication.user = response;
                Alert.add('success', gettext('Je tariefplan is geupdatet!'), 5000);
                $scope.busy = false;

                Analytics.trackEvent('Subscription', 'Changed', plan, couponCode);
            }).error(function() {
                Alert.add('danger', gettext('Er is iets misgelopen met het updaten van je tariefplan, probeer later opnieuw.'), 5000);
                $scope.busy = false;
            });
        }

    }
]);

'use strict';

angular.module('core').directive('animateElement', ['$window', 'Device',
    function($window, Device) {
        return {
            restriction: 'A',
            link: function(scope, element, attrs) {

                // we don't want animations on mobile
                if (Device.isMobile()) return;

                var waypointClass = 'main [class*="col-"]';
                var animationClass = 'fadeInUp';
                var delayTime;
                element.css({
                    opacity: '0'
                });

                element.waypoint(function() {
                    delayTime += 100;
                    $window.$(this).delay(delayTime).queue(function(next) {
                        $window.$(this).toggleClass('animated');
                        $window.$(this).toggleClass(animationClass);
                        delayTime = 0;
                        next();
                    });
                }, {
                    offset: '90%',
                    triggerOnce: true
                });

            }
        };
    }
]);

'use strict';

angular.module('core').directive('backImg', [

    function() {
        return {
            restriction: 'A',
            scope: {
                imgProvider: '@',
                imgLink: '@',
                isImgTag: '@'
            },
            link: function(scope, element, attrs) {

                var url = '';

                if (!scope.imgProvider || !scope.imgLink) return;

                if (scope.imgProvider === 'cloudinary')
                    url = 'https://res.cloudinary.com/dv8yfamzc/image/upload/' + scope.imgLink + '.png';
                else url = scope.imgLink;

                if (scope.isImgTag) {
                    element.attr('src', url);
                } else {
                    element.css({
                        'background-image': 'url(' + url + ')'
                    });
                }

            }
        };
    }
]);

'use strict';

angular.module('core').directive('datePicker', ['$window',
    function($window) {
        return {
            restrict: 'A',
            scope: {
                startDate: '@',
                dateModel: '=',
                minDate: '='
            },
            link: function postLink(scope, element, attrs) {

                scope.appendToELement = attrs.appendElement !== undefined;

                function selectDate(date) {
                    scope.dateModel = new Date(date);
                    scope.$apply();
                }

                var picker;
                var options = {
                    firstDay: 1,
                    format: 'DD/MM/YYYY',
                    onSelect: selectDate
                };

                if (scope.appendToELement) {
                    picker = new $window.Pikaday(options);
                    element.html(picker.el);
                } else {
                    options.field = element[0];
                    picker = new $window.Pikaday(options);
                }

                scope.$watch('startDate', function(newVal, oldVal) {
                    if (newVal !== oldVal) {
                        picker.setDate(new Date(newVal), true);
                    }
                });

                scope.$watch('minDate', function() {
                    var min = new Date(scope.minDate);
                    picker.setMinDate(min);

                    if (min > scope.dateModel)
                        picker.setDate(min, true);
                });

            }
        };
    }
]);

'use strict';

angular.module('core').directive('guidedTour', [ '$window',
    function($window) {
        return {
            template: '<div class="popover">' +
                 '<div class="arrow"></div>' +
                  '<h3 class="popover-title"><a href="#" class="close">&times;</a><i class="icon-info-circled"></i> Rondleiding</h3>' +
                  '<div class="popover-content">' +
                    '<p class="tour-text"></p>' +
                    '<button style="display: none;" class="tour-close btn btn-blue btn-xs pull-right">Sluiten</button>' +
                    '<button class="tour-next btn btn-green btn-xs pull-right">Volgende <i class="icon-right-1"></i></button><br>' +
                  '</div>' +
               '</div>',
            restriction: 'E',
            transclude: true,
            scope: {
                connectedElement: '@',
                step: '@',
                alignment: '@',
                guide: '=',
                onTourEnd: '&'
            },
            link: function(scope, element, attrs) {

                var connectedElement = $window.$(scope.connectedElement);
                var popoverElement = element.find('.popover');
                var nextButton = element.find('button');
                var closeButton = element.find('.close');

                if (scope.alignment) popoverElement.addClass(scope.alignment);
                if (attrs.laststep) {
                    popoverElement.find('.tour-next').hide();
                    popoverElement.find('.tour-close').show();
                }

                function positionELement() {
                    var pos = connectedElement.position();
                    var width = connectedElement.outerWidth();
                    var top = pos.top;
                    var left = ((width / 2) - (popoverElement.outerWidth() / 2)) + 'px';

                    if (scope.alignment === 'bottom') {
                        top += 20;
                    } else if (scope.alignment === 'right') {
                        top = pos.top;
                        left = connectedElement.outerWidth() + 'px';
                    } else if (scope.alignment === 'bottomleft') {
                        popoverElement.addClass('bottom');

                        top += 90;
                        left = pos.left;
                    }
                    
                    popoverElement.css({
                        position: 'absolute',
                        top: top,
                        left: left
                    }).addClass('active');
                }

                function showOrHide(currentStep) {
                    if (currentStep === +scope.step) {
                        positionELement();
                    } else {
                        popoverElement.removeClass('active');
                    }
                }

                scope.$watch('guide.step', function(newValue, oldValue) {
                    if (newValue !== oldValue) showOrHide(newValue);
                });

                nextButton.click(function(e) {
                    scope.guide.step++;
                    scope.$apply();

                    if (attrs.laststep) scope.onTourEnd();

                    e.preventDefault();
                    e.stopPropagation();
                });
                closeButton.click(function(e) {
                    scope.onTourEnd();

                    e.preventDefault();
                    e.stopPropagation();
                });

                element.find('.tour-text').text(scope.content);
                showOrHide(scope.guide.step);


                scope.$on('$destroy', function() {
                    nextButton.off('click');
                    closeButton.off('click');
                });
            },
            controller: ["$scope", "$transclude", function($scope, $transclude) {
                $transclude(function(clone,scope) {
                    $scope.content = clone.text();
                });
            }]
        };
    }
]);

'use strict';

angular.module('core').directive('onRepeatDone', [

    function() {
        return {
            restriction: 'A',
            link: function($scope, element, attributes) {
                if ($scope.$last) $scope.$emit(attributes.onRepeatDone || 'repeat_done', element);
            }
        };
    }
]);

'use strict';

angular.module('core').directive('shareButton', [

    function() {
        return {
            restriction: 'A',
            link: function(scope, element, attrs) {
                var site = attrs.shareButton;

                if (site === 'facebook') {
                    element.click(function(e) {
                        window.open(
                            '//www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(location.href),
                            'facebook-share-dialog',
                            'width=626,height=436'
                        );
                        e.preventDefault();
                    });
                } else if (site === 'twitter') {
                    element.click(function(e) {
                        window.open(
                            '//twitter.com/share?url=' + encodeURIComponent(location.href),
                            'facebook-share-dialog',
                            'width=626,height=448'
                        );
                        e.preventDefault();
                    });
                } else if (site === 'pinterest') {
                    element.click(function(e) {
                        window.open(
                            '//pinterest.com/pin/create/button/?url=S' + encodeURIComponent(location.href),
                            'facebook-share-dialog',
                            'width=626,height=436'
                        );
                        e.preventDefault();
                    });
                } else if (site === 'google') {
                    element.click(function(e) {
                        window.open(
                            '//plus.google.com/share?url=' + encodeURIComponent(location.href),
                            'facebook-share-dialog',
                            'width=626,height=359'
                        );
                        e.preventDefault();
                    });
                }
            }
        };
    }
]);

'use strict';

angular.module('core').directive('videoShuffle', ['$window', 'Device',
    function($window, Device) {
        return {
            template: '<video class="background-video" id="backgroundVideo" autoplay preload type="" style="opacity:0;" src=""></video>' +
                '<video class="background-video" id="stagingVideo" autoplay preload type="" style="opacity:0;" src=""></video>',
            restrict: 'A',
            link: function postLink(scope, element, attrs) {

                var FALLBACK_VIDEO_URL = '/modules/core/img/video/fallback_poster.jpg';

                // show a poster instead of a video on mobile
                if (Device.isMobile()) {
                    element.css({ 'background-image': 'url(' + FALLBACK_VIDEO_URL + ')' });
                    return;
                }

                var videoTimer = null;

                //Clips for the videos
                var clips = [
                    ['bike', 9900],
                    ['bikefar', 4900],
                    ['house1', 2900],
                    ['jonnyskateboard', 5900],
                    ['kidshouse', 1900],
                    ['leahdog', 4900],
                    ['majesticdog', 4900],
                    ['trackingdriveway', 4900],
                    ['trackingstreet', 3900]
                ];

                var settings = {
                    videoContainer: element.find('#backgroundVideo'),
                    stagingContainer: element.find('#stagingVideo')
                };

                var currentClip = 2;

                function resize() {
                    // get native video size
                    var videoHeight = settings.videoContainer[0].videoHeight,
                        videoWidth = settings.videoContainer[0].videoWidth;

                    // get wrapper size
                    var wrapperWidth = element.width();

                    var calculatedVideoHeight = wrapperWidth / (videoWidth / videoHeight);

                    settings.videoContainer.css({
                        'width': wrapperWidth,
                        'height': calculatedVideoHeight
                    });
                    settings.stagingContainer.css({
                        'width': wrapperWidth,
                        'height': calculatedVideoHeight
                    });

                    settings.videoContainer.animate({
                        opacity: 1
                    }, 2000);
                }

                function stopVideo() {
                    clearTimeout(videoTimer);
                    settings.stagingContainer[0].pause();
                    settings.videoContainer[0].pause();
                }

                function buildInitialVideo() {
                    if (settings.videoContainer[0].canPlayType('video/webm')) {
                        settings.supportedType = '.webm';
                        settings.videoContainer.attr('type', 'video/webm;codecs=\'vp8\'');
                    } else {
                        settings.supportedType = '.mp4';
                        settings.videoContainer.attr('type', 'video/mp4;codecs=\'avc1.42E01E, mp4a.40.2\'');
                    }

                    clips = $window._.shuffle(clips);

                    settings.videoContainer.attr('src', '/modules/core/img/video/' + clips[0][0] + settings.supportedType);
                    settings.videoContainer[0].load();

                    settings.stagingContainer.attr('src', '/modules/core/img/video/' + clips[1][0] + settings.supportedType);
                    settings.stagingContainer[0].load();
                    settings.stagingContainer[0].pause();

                    videoTimer = window.setTimeout(function() {
                        loop();
                    }, clips[0][1]);
                }

                function loop() {
                    videoTimer = null;

                    var nextClip = clips[1][0],
                        currentTime = clips[1][1];

                    if (!clips[currentClip + 1]) {
                        currentClip = 1;
                        nextClip = clips[1][0];
                        currentTime = clips[clips.length - 1][1];
                    } else {
                        nextClip = clips[currentClip + 1][0];
                        currentTime = clips[currentClip][1];
                    }

                    if (settings.videoContainer.css('opacity') === '0') {

                        settings.videoContainer[0].play();
                        settings.videoContainer.animate({
                            'opacity': 1
                        }, 150, function() {
                            settings.stagingContainer.animate({
                                'opacity': 0
                            }, 0);
                            settings.stagingContainer.attr('src', '/modules/core/img/video/' + nextClip + settings.supportedType);
                            settings.stagingContainer[0].load();
                            settings.stagingContainer[0].pause();
                        });
                    } else {

                        settings.stagingContainer[0].play();
                        settings.stagingContainer.animate({
                            'opacity': 1
                        }, 150, function() {
                            settings.videoContainer.animate({
                                'opacity': 0
                            }, 0);
                            settings.videoContainer.attr('src', '/modules/core/img/video/' + nextClip + settings.supportedType);
                            settings.videoContainer[0].load();
                            settings.videoContainer[0].pause();
                        });
                    }
                    currentClip++;

                    videoTimer = window.setTimeout(function() {
                        loop();
                    }, currentTime);
                }

                buildInitialVideo();
                resize();

                scope.$on('$destroy', function() {
                    clearTimeout(videoTimer);
                    settings.stagingContainer[0].pause();
                    settings.videoContainer[0].pause();
                });

                // window.bind('resize', function () {
                //     resize();
                // });
            }
        };
    }
]);

'use strict';

angular.module('core').service('Alert', ['$rootScope', '$timeout',
    function($rootScope, $timeout) {
        $rootScope.alerts = [];
        var self = this;

        this.add = function(type, msg, timeout) {
            $rootScope.alerts.push({
                type: type,
                msg: msg,
                close: function() {
                    self.closeAlert(this);
                }
            });

            if (timeout) {
                $timeout(function() {
                    self.closeAlert(this);
                }, timeout);
            }
        };

        this.closeAlert = function(alert) {
            return this.closeAlertIdx($rootScope.alerts.indexOf(alert));
        };

        this.closeAlertIdx = function(index) {
            return $rootScope.alerts.splice(index, 1);
        };

    }
]);

'use strict';

angular.module('core').service('Device', ['$window',
    function($rootScope, $window) {

        this.isMobile = function() {
            var check = false;
            (function(a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || $window.opera);
            return check;
        };

    }
]);

'use strict';

angular.module('core').service('ExceptionHandler', ['$exceptionHandler', 'Analytics',
    function($exceptionHandler, Analytics) {

        return function(exception, cause) {
            console.error(exception.stack);
            Analytics.trackException(cause);
        };

    }
]);

'use strict';

angular.module('core').service('Modal', ['$modal',
    function($modal) {
        var modalInstance;

        this.signup = function() {
            var options = {
                templateUrl: '/modules/users/views/modals/signup-modal.client.view.html',
                controller: 'AuthenticationController',
                windowClass: 'small'
            };

            return this.showModal(options, {});
        };

        this.signin = function() {
            var options = {
                templateUrl: '/modules/users/views/modals/signin-modal.client.view.html',
                controller: 'AuthenticationController',
                windowClass: 'small'
            };

            return this.showModal(options, {});
        };

        this.contact = function(info) {
            var options = {
                templateUrl: '/modules/rooms/views/modals/contact-modal.client.view.html',
                // controller: 'RoomsController',
                resolve: {
                    contactInfo: function() {
                        return info;
                    }
                }
            };

            return this.showModal(options, {});
        };

        this.reservation = function(info) {
            var options = {
                templateUrl: '/modules/rooms/views/modals/reservation-modal.client.view.html',
                controller: 'ModalController',
                resolve: {
                    modalContent: function() {
                        return info;
                    }
                }
            };

            return this.showModal(options, {});
        };

        this.changeAddress = function(addressDetails) {
            var options = {
                templateUrl: '/modules/rooms/views/modals/change-address-modal.client.view.html',
                controller: 'ManageRoomController',
                resolve: {
                    addressDetails: function() {
                        return addressDetails;
                    }
                }
            };

            return this.showModal(options, {});
        };

        this.confirm = function(type) {
            var options = {
                templateUrl: '/modules/core/views/modals/confirm-modal.client.view.html',
                windowClass: 'small',
                controller: 'ModalController',
                resolve: {
                    modalContent: function() {
                        return type;
                    }
                }
            };

            return this.showModal(options, {});
        };


        this.payment = function(paymentOptions) {
            var options = {
                templateUrl: '/modules/core/views/modals/payment-modal.client.view.html',
                controller: 'ModalPaymentController',
                resolve: {
                    options: function() {
                        return paymentOptions;
                    }
                }
            };

            return this.showModal(options, {});
        };

        var modalDefaults = {
            backdrop: true,
            keyboard: true,
            modalFade: true,
            templateUrl: '/modules/core/views/modal.client.view.html'
        };

        var modalOptions = {
            closeButtonText: 'Close',
            actionButtonText: 'OK',
            headerText: 'Proceed?',
            bodyText: 'Perform this action?'
        };

        this.showModal = function(customModalDefaults, customModalOptions) {
            if (!customModalDefaults) customModalDefaults = {};
            return this.show(customModalDefaults, customModalOptions);
        };

        this.show = function(customModalDefaults, customModalOptions) {
            //Create temp objects to work with since we're in a singleton service
            var tempModalDefaults = {};
            var tempModalOptions = {};

            //Map angular-ui modal custom defaults to modal defaults defined in service
            angular.extend(tempModalDefaults, modalDefaults, customModalDefaults);

            //Map modal.html $scope custom properties to defaults defined in service
            angular.extend(tempModalOptions, modalOptions, customModalOptions);

            if (!tempModalDefaults.controller) {
                tempModalDefaults.controller = function($scope, $modalInstance) {
                    $scope.modalOptions = tempModalOptions;
                    $scope.modalOptions.ok = function(result) {
                        $modalInstance.close(result);
                    };
                    $scope.modalOptions.close = function(result) {
                        $modalInstance.dismiss('cancel');
                    };
                };
            }

            return $modal.open(tempModalDefaults).result;
        };

    }
]);

'use strict';

angular.module('core').factory('Socket', ['socketFactory',
    function(socketFactory) {

        return socketFactory();

    }
]);

'use strict';

angular.module('core').service('Statistics', ['$http', 'localStorageService',
    function($http, localStorageService) {

        var uniqueViews = false;

        this.aggregate = function(roomId, type) {
            // type can be 'views', 'messages', 'reservations', 'favorites'

            if (uniqueViews) {
                var seenRooms = localStorageService.get('viewedRooms') || [];
                if (seenRooms.indexOf(roomId) === -1) {
                    postStatistic(roomId, type);
                    seenRooms.push(roomId);
                }
                localStorageService.set('viewedRooms', seenRooms);
            } else {
                postStatistic(roomId, type);
            }
        };

        function postStatistic(roomId, type) {
            $http.post('/api/statistics/' + roomId + '/aggregate', {
                type: type
            });
        }

    }
]);

'use strict';

// Setting up route
angular.module('promote').config(['$stateProvider',
    function($stateProvider) {

        // Home state routing
        $stateProvider.
        state('promote', {
            url: '/promote',
            templateUrl: '/modules/promote/views/promote.client.view.html'
        });
    }
]);

'use strict';

// Setting up route
angular.module('promote').config([ 'MetaProvider',
    function(MetaProvider) {
        MetaProvider
          .when('/promote', {
            title: 'Je bedrijf adverteren'
          });
    }
]);

'use strict';

angular.module('promote').controller('PromoteController', ['$scope','Authentication',
    function($scope, Authentication) {
        $scope.authentication = Authentication;

        $scope.init = function() {
            $scope.htmlReady(); 
        };

    }
]);

'use strict';

//Rooms service used to communicate Rooms REST endpoints
angular.module('promote').factory('Ads', ['$resource',
    function($resource) {
        return $resource('/api/ads/:adId', {
            adId: '@_id'
        }, {
            update: {
                method: 'PUT'
            }
        });
    }
]);

'use strict';

// Setting up route
angular.module('rooms').config([ 'MetaProvider',
    function(MetaProvider) {
        MetaProvider
          .when('/rooms/new', {
            title: 'Advertentie toevoegen'
          })

          .when('/rooms/:roomId/edit/:nav', {
            title: 'Advertentie aanpassen'
          })

          .when('/rooms/:roomId/analytics', {
            title: 'Analytics bekijken'
          })

          .when('/rooms/notfound', {
            title: 'Niet gevonden'
          });
    }
]);

'use strict';

//Setting up route
angular.module('rooms').config(['$stateProvider',
    function($stateProvider) {
        // Rooms state routing
        $stateProvider.
        state('createRoom', {
            url: '/rooms/new',
            templateUrl: '/modules/rooms/views/create-room.client.view.html'
        }).
        state('viewRoom', {
            url: '/l/:roomId/:city/:title',
            templateUrl: '/modules/rooms/views/view-room.client.view.html'
        }).
        state('editRoom', {
            url: '/rooms/:roomId/edit/:nav',
            templateUrl: '/modules/rooms/views/edit-room.client.view.html'
        }).
        state('analytics', {
            url: '/rooms/:roomId/analytics',
            templateUrl: '/modules/rooms/views/analytics.client.view.html'
        }).
        state('notFound', {
            url: '/rooms/notfound',
            templateUrl: '/modules/rooms/views/not-found.client.view.html'
        });
    }
]);

'use strict';

// Rooms controller
angular.module('rooms').controller('AnalyticsController', ['$scope', '$location', '$http', '$stateParams', 'Authentication', 'Rooms',
    function($scope, $location, $http, $stateParams, Authentication, Rooms) {
        $scope.authentication = Authentication;

        $scope.statisticsData = [];

        // If user is not signed in then redirect back home
        if (!Authentication.user) $location.path('/');

        $scope.init = function() {
            $scope.findOne();
        };

        // Find existing Room
        $scope.findOne = function() {
            $scope.room = Rooms.get({
                roomId: $stateParams.roomId
            }, getStatisticsData);
        };

        function getStatisticsData() {
            $http.get('/api/statistics/' + $scope.room._id + '/lastmonth').success(function(response) {
                $scope.statisticsData = response;

                $scope.htmlReady(); 
            });
        }

    }
]);

'use strict';

angular.module('rooms').controller('CreateRoomController', ['$scope', '$location', '$state', 'Authentication', 'Rooms', 'Modal', 'Geocoder', '$http', 'Analytics',
    function($scope, $location, $state, Authentication, Rooms, Modal, Geocoder, $http, Analytics) {
        $scope.authentication = Authentication;

        $scope.createForm = {
            address: '',
            roomType: ''
        };
        $scope.autocompleteOptions = {
            country: 'be',
            watchEnter: true
        };
        $scope.addressDetails = null;
        $scope.creationStep = 1;
        $scope.busy = false;
        $scope.allowed = false;

        $scope.init = function() {
            if (Authentication.user) {
                $scope.creationStep = 2;
                checkUserRoomCount();
            } else {
                $scope.allowed = true;
            }

            $scope.htmlReady(); 
        };

        // Create new Room
        $scope.create = function() {

            // we need a roomType
            if (!$scope.createForm.roomType) return;

            if ($scope.addressDetails === null) {
                doSearchLookup($scope.createForm.address);
                return;
            }

            // Create new Room object
            var room = new Rooms({
                location: {
                    street: $scope.addressDetails.street,
                    city: $scope.addressDetails.city,
                    country: $scope.addressDetails.country
                },
                loc: {
                    type: 'Point',
                    coordinates: $scope.addressDetails.geo
                },
                classification: $scope.createForm.roomType
            });

            // Redirect after save
            room.$save(function(response) {
                Analytics.trackEvent('Room', 'Created', 'success');
                $location.path('/rooms/' + response._id + '/edit/');
            }, function(errorResponse) {
                Analytics.trackEvent('Room', 'Created', 'failure');
                $scope.error = errorResponse.data.message;
            });

            // Clear form fields
            $scope.createForm.address = '';
        };

        $scope.openSingupModal = function() {
            Modal.signup().then(function() {
                $scope.creationStep = 2;
            });
        };

        $scope.openSinginModal = function() {
            Modal.signin().then(function() {
                $scope.creationStep = 2;
            });
        };

        function doSearchLookup(address) {
            Geocoder.geocodeAddress(address).then(function(result) {

                // we need a valid street address
                if (result.accuracy < 7) return;

                $scope.addressDetails = {
                    street: result.street + ' ' + result.streetNumber,
                    city: result.city,
                    country: result.country,
                    geo: [result.lng, result.lat]
                };

                $scope.create();
            });
        }

        function checkUserRoomCount() {
            $http.get('/api/roomcount').success(function() {
                $scope.allowed = true;
            }).error(function(response) {
                $state.transitionTo('pricing', {
                    message: 'upgrade'
                });
            });
        }
    }
]);

'use strict';

// Rooms controller
angular.module('rooms').controller('ManageRoomController', ['$scope', '$stateParams', '$location', 'Authentication', 'Rooms', 'UserSettings', '$window', 'Amenity', '$upload', '$http', 'Modal', 'Alert', 'gettext',
    function($scope, $stateParams, $location, Authentication, Rooms, UserSettings, $window, Amenity, $upload, $http, Modal, Alert, gettext) {
        $scope.authentication = Authentication;

        // If user is not signed in then redirect back home
        if (!Authentication.user) $location.path('/');

        $scope.busy = false;
        $scope.nav = 'general';
        $scope.amenities = Amenity.list();
        $scope.errors = [];

        $scope.newAddress = '';
        $scope.newAddressDetails = {};

        $scope.guide = {
            enabled: Authentication.user.settings.tutorial,
            step: 1
        };

        // Init
        $scope.init = function() {
            if ($stateParams.nav) $scope.nav = $stateParams.nav;
            if (!$stateParams.roomId) $location.path('/');

            $scope.room = Rooms.get({
                roomId: $stateParams.roomId
            }, postLoad, function() {
                // room not found, redirect
                $location.path('/dashboard/rooms');
            });

            $scope.$on('dropbox_chosen', onDropboxSelect);

            $scope.htmlReady(); 
        };

        $scope.guideEnded = function() {
            $scope.guide.enabled = false;
            UserSettings.set('tutorial', false);

            $scope.$apply();
        };

        // Update existing Room
        $scope.update = function() {
            $scope.room.$update(function() {
                flashSavedText();
            }, function(errorResponse) {
                $scope.error = errorResponse.data.message;
            });
        };

        $scope.onImageSelect = function($files) {
            if ($files.length > 0) uploadImage($files[0]);
        };

        $scope.removeImage = function(index) {
            $scope.busy = true;

            $http.post('/api/rooms/' + $scope.room._id + '/removepicture', {
                index: index
            }).success(function(response) {
                $scope.room.pictures.splice(index, 1);
                $scope.busy = false;
            }).error(function(response) {
                $scope.busy = false;
            });
        };

        $scope.toggleAmenitySelection = function(amenity) {
            var idx = $scope.room.amenities.indexOf(amenity);

            if (idx > -1) {
                $scope.room.amenities.splice(idx, 1);
            } else {
                $scope.room.amenities.push(amenity);
            }
        };

        $scope.isAmenityChecked = function(amenity) {
            if ($scope.room.amenities)
                return $scope.room.amenities.indexOf(amenity) !== -1;
            else return false;
        };

        $scope.setTab = function(tab) {
            $scope.nav = tab;
            $location.path('/rooms/' + $scope.room._id + '/edit/' + tab);
        };

        $scope.tabHasError = function(tab) {
            return $scope.errors.indexOf(tab) !== -1;
        };

        $scope.openAddressModal = function() {
            var obj = {
                newAddress: $scope.newAddress,
                newAddressDetails: $scope.newAddressDetails
            };
            Modal.changeAddress(obj).then(function(result) {
                $scope.room.location = {
                    street: result.street + ' ' + result.streetNumber,
                    city: result.city,
                    country: result.country
                };
                $scope.room.loc = {
                    type: 'Point',
                    coordinates: result.geo
                };
                $scope.$broadcast('room_loaded', $scope.room);
            });
        };

        $scope.visibilityText = function(item) {
            return item ? 'online' : 'offline';
        };

        $scope.deleteRoom = function() {
            Modal.confirm('room').then(function() {
                $scope.room.$remove(function() {
                    $location.path('/dashboard/rooms');
                });
            });
        };

        function postLoad() {
            if ($scope.room.user._id !== Authentication.user._id) $location.path('/');

            watchForUpdates();
        }

       function watchForUpdates () {
            $scope.$broadcast('room_loaded', $scope.room);
            checkRoomCompleteness();

            var updateFunction = $window._.debounce($scope.update, 800);

            function watchRoomProperties() {
                return {
                    visible: $scope.room.visible,
                    pictures: $scope.room.pictures,
                    leaseType: $scope.room.leaseType,
                    available: $scope.room.available,
                    loc: $scope.room.loc,
                    location: $scope.room.location,
                    info: $scope.room.info,
                    amenities: $scope.room.amenities,
                    price: $scope.room.price,
                    surface: $scope.room.surface,
                    cohabit: $scope.room.cohabit
                };
            }

            $scope.$watch(watchRoomProperties, function(newValue, oldValue) {
                if (newValue !== oldValue && !$scope.busy) {
                    checkRoomCompleteness();
                    updateFunction();
                }
            }, true);
        }

        function checkRoomCompleteness() {
            var errors = [];

            if (!$scope.room.info.title || $scope.room.info.title === '') errors.push('general');
            if (!$scope.room.price.base || $scope.room.price.base === 0) errors.push('costs');
            if (!$scope.room.available.immediately && (!$scope.room.available.from || !$scope.room.available.till || new Date($scope.room.available.till)) < new Date()) errors.push('availability');

            $scope.errors = errors;
        }

        function uploadImage(image) {
            if ($scope.room.pictures.length === 8) return;

            $scope.busy = true;
            $upload.upload({
                url: '/api/rooms/' + $scope.room._id + '/upload',
                data: {
                    index: $scope.room.pictures.length
                },
                file: image
            }).success(function(data, status, headers, config) {
                $scope.room.pictures.push({
                    provider: 'cloudinary',
                    link: data.id
                });
                $scope.busy = false;
            }).error(function(response) {
                $scope.busy = false;
                Alert.add('danger', gettext('Er was een probleem bij het toevoegen van de afbeelding, probeer later eens opnieuw.'), 5000);
            });
        }

        function onDropboxSelect(e, files) {
            if ($scope.room.pictures.length === 8) return;

            $scope.busy = true;
            files.forEach(function(file) {
                $http.post('/api/rooms/' + $scope.room._id + '/upload', {
                    link: file.link,
                    index: $scope.room.pictures.length
                }).success(function(data) {
                    $scope.room.pictures.push({
                        provider: 'cloudinary',
                        link: data.id
                    });
                    $scope.busy = false;
                }).error(function(response) {
                    $scope.busy = false;
                    Alert.add('danger', gettext('Er was een probleem bij het toevoegen van de afbeelding, probeer later eens opnieuw.'), 5000);
                });
            });
        }

        function flashSavedText() {
            $scope.$broadcast('blink_text');
        }

    }
]);

'use strict';

// Rooms controller
angular.module('rooms').controller('ModalController', ['$scope', '$modalInstance', 'modalContent',
    function($scope, $modalInstance, modalContent) {
        $scope.modalContent = modalContent;
    }
]);

'use strict';

// Rooms controller
angular.module('rooms').controller('RoomsController', ['$rootScope', '$scope', '$stateParams', '$http', 'Authentication', 'Rooms', 'Amenity', 'Modal', 'Alert', 'Statistics', 'Meta', '$location', 'Enforcer', 'Analytics', 'gettext',
    function($rootScope, $scope, $stateParams, $http, Authentication, Rooms, Amenity, Modal, Alert, Statistics, Meta, $location, Enforcer, Analytics, gettext) {
        $scope.authentication = Authentication;

        $scope.contactInfo = {
            appointmentDate: new Date(),
            name: '',
            email: ''
        };
        $scope.currentDate = new Date();
        $scope.appointmentDate = new Date();
        $scope.otherRooms = [];
        $scope.amenities = Amenity.list();

        $scope.isOverlay = false;


        $scope.init = function() {
            $scope.findOne();
        };

        // Find existing Room
        $scope.findOne = function() {
            $scope.room = Rooms.get({
                roomId: $stateParams.roomId
            }, postLoad, loadFailure);
        };

        $scope.isAmenityChecked = function(room, amenity) {
            if ($scope.room.amenities)
                return room.amenities.indexOf(amenity.value) !== -1;
            else return false;
        };

        $scope.openReservationModal = function() {
            Enforcer.do(function() {
                Modal.reservation($scope.appointmentDate).then(sendReservation);
            });
        };

        $scope.openContactModal = function() {
            Enforcer.do(function() {
                Modal.contact($scope.contactInfo).then(sendMessage);
            });
        };

        $scope.toggleFavorite = function() {
            Enforcer.do(function() {
                sendFavorite();
            });
        };

        $scope.isInfavorites = function() {
            if (Authentication.user)
                return Authentication.user.favorites.indexOf($scope.room._id) !== -1;
            else return false;
        };

        $scope.closeOverlay = function() {
            $rootScope.$broadcast('close_overlay');
        };

        $scope.isOverlay = function() {
            return $stateParams.isOverlay;
        };

        $scope.visibilityText = function(item) {
            return item ? 'online' : 'offline';
        };

        $scope.setVisibility = function() {
            $http.put('/api/rooms/' + $scope.room._id, {
                visible: $scope.room.visible
            });
        };

        // helper for repeating something n number of times
        $scope.getNumber = function(num) {
            var obj = [];
            for (var i = 0; i < num; i++) {
                obj.push(i);
            }
            return obj;
        };

        $scope.getCostPeriod = function(period) {
            if (period === 'month') return gettext('per maand');
            else if (period === 'month') return gettext('per drie maand');
            else return gettext('per jaar');
        };

        $scope.getClasification = function() {
            var classification = $scope.room.classification;
            if (classification === 'room') return gettext('Kamer');
            else if (classification === 'appartment') return gettext('Appartement');
            else return gettext('Huis');
        };

        function sendFavorite() {
            $http.post('/api/rooms/' + $scope.room._id + '/favorite').success(function(response) {
                var index = Authentication.user.favorites.indexOf($scope.room._id);
                if (index === -1) {
                    Statistics.aggregate($scope.room._id, 'favorites');

                    Authentication.user.favorites.push($scope.room._id);
                    Alert.add('success', gettext('Toegevoegd aan favorieten!'), 3000);

                    Analytics.trackEvent('Room', 'Favorite');
                } else {
                    Authentication.user.favorites.splice(index, 1);
                }
            }).error(function(response) {
                Alert.add('danger', gettext('Er was een probleem bij het toevoegen aan je favorieten, probeer later eens opnieuw.'), 5000);
            });
        }

        function sendMessage(message) {
            Statistics.aggregate($scope.room._id, 'messages');

            $http.post('/api/rooms/' + $scope.room._id + '/message', {
                message: message
            }).success(function(response) {
                Alert.add('success', gettext('Je bericht is verzonden!'), 5000);
                Analytics.trackEvent('Room', 'Message');
            }).error(function(response) {
                Alert.add('danger', gettext('Er was een probleem met het verzenden van je bericht, probeer later eens opnieuw.'), 5000);
            });
        }

        function sendReservation(extraMessage) {
            Statistics.aggregate($scope.room._id, 'reservations');

            $http.post('/api/rooms/' + $scope.room._id + '/message', {
                message: $scope.appointmentDate.getTime(),
                messageType: 'reservation'
            }).success(function(response) {
                if (extraMessage) sendMessage(extraMessage);
                else Alert.add('success', 'Je aanvraag is verzonden!', 5000);
                Analytics.trackEvent('Room', 'Reservation');
            }).error(function(response) {
                Alert.add('danger', gettext('Er was een probleem met het verzenden van je bericht, probeer later eens opnieuw.'), 5000);
            });
        }

        function postLoad() {

            Meta.add('/l/:roomId/:city/:title', getMetaData());
            
            // increment view count for statistics
            Statistics.aggregate($scope.room._id, 'views');

            $scope.otherRooms = Rooms.getRoomsOfSameLocation({
                roomId: $scope.room._id
            });
            $scope.$broadcast('room_loaded', $scope.room);
            if ($scope.room.pictures.length === 0) $scope.$emit('pictures_rendered');

            $scope.htmlReady(); 
        }

        function getMetaData() {
            var meta = {};

            if (!$scope.room.info.title) {
                meta.title = $scope.room.location.street;
            } else {
                meta.title = $scope.room.info.title;
                meta.description = $scope.room.info.description;
            }

            if ($scope.room.pictures.length > 0) {
                var picture = $scope.room.pictures[0];

                if (picture.provider === 'cloudinary')
                    meta.image = 'https://res.cloudinary.com/dv8yfamzc/image/upload/' + picture.link + '.png';
                else meta.image = picture.link;
            }

            return meta;
        }

        function loadFailure(response) {
            console.log(response);
            // $location.path('/rooms/notfound');
        }
    }
]);

'use strict';

angular.module('rooms').directive('addressLookup', ['$window', 'Geocoder',
    function($window, Geocoder) {
        return {
            restrict: 'A',
            scope: {
                resultObject: '='
            },
            require: '^form',
            link: function(scope, element, attr, form) {

                form.$setValidity('', false);

                var autocomplete = new $window.google.maps.places.Autocomplete(element[0], {
                    types: ['geocode']
                });
                $window.google.maps.event.addListener(autocomplete, 'place_changed', function() {
                    var place = autocomplete.getPlace();

                    if (place.address_components) getAddressDetails(place);
                    else geocode(place.name);
                });

                function geocode(address) {
                    Geocoder.geocodeAddress(address).then(function(result) {

                        element.val(result.formattedAddress);

                        scope.resultObject = {
                            street: result.street,
                            streetNumber: result.streetNumber,
                            city: result.city,
                            country: result.country,
                            geo: [result.lng, result.lat]
                        };

                        checkValidity();

                    });
                }

                function getAddressDetails(place) {
                    var streetNumber = '';
                    var street = '';
                    var city = '';
                    var country = '';

                    for (var i = 0; i < place.address_components.length; i++) {
                        var type = place.address_components[i].types[0];
                        switch (type) {
                            case 'street_number':
                                streetNumber = place.address_components[i].long_name;
                                break;
                            case 'route':
                                street = place.address_components[i].long_name;
                                break;
                            case 'locality':
                                city = place.address_components[i].long_name;
                                break;
                            case 'country':
                                country = place.address_components[i].long_name;
                                break;
                        }
                    }

                    scope.resultObject = {
                        street: street,
                        streetNumber: streetNumber,
                        city: city,
                        country: country,
                        geo: [place.geometry.location.lng(), place.geometry.location.lat()]
                    };

                    checkValidity();

                }

                function checkValidity() {
                    if (!scope.resultObject.street || scope.resultObject.street === '') {
                        form.$setValidity('noStreet', false);
                    } else {
                        form.$setValidity('noStreet', true);
                    }
                    if (!scope.resultObject.streetNumber || scope.resultObject.streetNumber === '') {
                        form.$setValidity('noStreetNumber', false);
                    } else {
                        form.$setValidity('noStreetNumber', true);
                    }

                }

            }
        };
    }
]);

'use strict';

angular.module('core').directive('blinkText', [

    function() {
        return {
            restrict: 'A',
            link: function(scope, element, attributes) {
                scope.$on('blink_text', function(event) {
                    element.finish().show().fadeOut(1400);
                });
            }
        };
    }
]);

'use strict';

angular.module('rooms').directive('owlCarousel', ['$window',
    function($window) {
        return {
            restrict: 'A',
            link: function postLink(scope, element, attrs) {

                var defaults = {
                    autoPlay: 5000,
                    slideSpeed: 200,
                    paginationSpeed: 600,
                    rewindSpeed: 800,
                    stopOnHover: true,
                    navigation: true,
                    pagination: attrs.owlPagination === 'true',
                    rewindNav: true,
                    singleItem: true,
                    autoHeight: false,
                    lazyLoad: false,
                    mouseDrag: false,
                    navigationText: ['<i class="icon-left-open-mini"></i>', '<i class="icon-right-open-mini"></i>']
                };

                var el = $window.$(element);
                var carousel;

                scope.$on('pictures_rendered', function() {
                    carousel = el.owlCarousel(defaults).data('owlCarousel');
                });

                scope.$on('$destroy', function() {
                    if (carousel) carousel.destroy();
                });
            }
        };
    }
]);

'use strict';

angular.module('rooms').directive('checkAddress', [
    function() {
        return {
            restrict: 'A',
            link: function(scope, element, attributes, formController) {

                scope.createRoomForm.$setValidity('input', false);

                scope.$watch('autoCompleteDetails', function(newDetails, oldDetails) {
                    if (newDetails) {
                        scope.createRoomForm.$setValidity('input', true);

                        var streetNumber = '';
                        var street = '';
                        var city = '';
                        var country = '';

                        for (var i = 0; i < newDetails.address_components.length; i++) {
                            var type = newDetails.address_components[i].types[0];
                            switch (type) {
                                case 'street_number':
                                    streetNumber = newDetails.address_components[i].long_name;
                                    break;
                                case 'route':
                                    street = newDetails.address_components[i].long_name;
                                    break;
                                case 'locality':
                                    city = newDetails.address_components[i].long_name;
                                    break;
                                case 'country':
                                    country = newDetails.address_components[i].long_name;
                                    break;
                            }
                        }

                        if (street === '') {
                            scope.createRoomForm.$setValidity('noStreet', false);
                        } else {
                            scope.createRoomForm.$setValidity('noStreet', true);
                        }
                        if (streetNumber === '') {
                            scope.createRoomForm.$setValidity('noStreetNumber', false);
                        } else {
                            scope.createRoomForm.$setValidity('noStreetNumber', true);
                        }

                        if (scope.createRoomForm.$valid) {
                            scope.addressDetails = {
                                street: street + ' ' + streetNumber,
                                city: city,
                                country: country,
                                geo: [newDetails.geometry.location.lng(), newDetails.geometry.location.lat()]
                            };
                        }
                    }
                });
            }
        };
    }
]);

'use strict';

angular.module('core').directive('dropboxChooser', ['$window',
    function($window) {
        return {
            restrict: 'A',
            scope: {
                chooserSuccess: '&'
            },
            link: function(scope, element, attributes) {

                var options = {
                    success: function(files) {
                        scope.$emit('dropbox_chosen', files);
                    },
                    linkType: 'direct',
                    multiselect: false,
                    extensions: ['images'],
                };

                element.click(function() {
                    $window.Dropbox.choose(options);
                });
            }
        };
    }
]);

'use strict';

angular.module('core').directive('limitText', [

    function() {
        return {
            require: 'ngModel',
            restrict: 'A',
            scope: {
                model: '=ngModel'
            },
            link: function(scope, element, attributes) {
                scope.$watch('model', function(newValue, oldValue) {
                    if (newValue !== oldValue && scope.model) {
                        scope.model = scope.model.substring(0, attributes.limitText);
                    }
                });
            }
        };
    }
]);

'use strict';

angular.module('rooms').directive('roomMap', ['$window',
    function($window) {
        return {
            template: '<div id="map" class="map-canvas"></div>',
            restrict: 'A',
            link: function postLink(scope, element, attrs) {

                var layer = null;
                var map = $window.L.mapbox.map(element[0], 'defreek.j27p0821', {
                    zoomControl: false
                });

                scope.$on('room_loaded', function(event, room) {
                    map.setView([room.loc.coordinates[1], room.loc.coordinates[0]], 15);

                    // Disable drag and zoom handlers.
                    map.dragging.disable();
                    map.touchZoom.disable();
                    map.doubleClickZoom.disable();
                    map.scrollWheelZoom.disable();

                    // Disable tap handler, if present.
                    if (map.tap) map.tap.disable();

                    if (layer) layer.clearLayers();
                    layer = $window.L.mapbox.featureLayer({
                        type: 'Feature',
                        geometry: room.loc,
                        properties: {
                            'marker-size': 'medium',
                            'marker-color': '#f44',
                            'marker-symbol': getRoomTypeIcon(room.classification)
                        }
                    }).addTo(map);

                });

                scope.$on('$destroy', function() {
                    map.remove();
                });

                function getRoomTypeIcon(roomType) {
                    if (roomType === 'room') return 'lodging';
                    else if (roomType === 'appartment') return 'commercial';
                    else return 'building';
                }
            }
        };
    }
]);

'use strict';

angular.module('core').directive('statisticsChart', ['$window',
    function($window) {
        return {
            restriction: 'E',
            require: 'ngModel',
            scope: {
                model: '=ngModel'
            },
            link: function(scope, element, attrs) {

                function getValue(value) {
                    if (!value) return 0;
                    else return value;
                }

                function generateDateRange(start, stop) {
                    var dateArray = d3.time.day.range(start, stop);
                    var newData = [];

                    dateArray.forEach(function(value) {

                        var obj = {
                            date: value
                        };
                        obj[dataAttribute] = 0;
                        newData.push(obj);

                    });

                    return newData;
                }

                function interpolateDataInRange(data, range, aggregate) {

                    for (var i = 0; i < range.length; i++) {
                        var value = 0;

                        for (var j = 0; j < data.length; j++) {
                            data[j].date = new Date(data[j].date);

                            if (data[j].date.getTime() === range[i].date.getTime()) {
                                value = getValue(data[j][dataAttribute]);
                                break;
                            }

                        }

                        if (i === 0 || !aggregate) {
                            range[i][dataAttribute] = value;
                        } else if (i > 0 && aggregate) {
                            range[i][dataAttribute] = range[i - 1][dataAttribute] + value;
                        }

                    }

                }

                var d3 = $window.d3;
                var dataAttribute = attrs.value;
                var startDate = new Date();
                startDate = startDate.setDate(startDate.getDate() - 30);
                var range = generateDateRange(startDate, new Date());
                var aggregateAttr = attrs.aggregate === 'true';

                scope.$watch('model', function(newValue) {

                    if (newValue.length > 0) {
                        interpolateDataInRange(newValue, range, aggregateAttr);
                        drawChart(range);
                    }
                });

                function drawChart(data) {

                    var margin = {
                            top: 20,
                            right: 30,
                            bottom: 30,
                            left: 30
                        },
                        width = element.parent().outerWidth() - margin.left - margin.right - 55,
                        height = 200 - margin.top - margin.bottom;

                    var x = d3.time.scale()
                        .range([0, width]);

                    var y = d3.scale.linear()
                        .range([height, 0]);

                    var xAxis = d3.svg.axis()
                        .scale(x)
                        .orient('bottom');

                    var yAxis = d3.svg.axis()
                        .scale(y)
                        .orient('left')
                        .tickSize(-width)
                        .ticks(5)
                        .tickFormat(d3.format('d'));

                    var keyAccessor = function(d) {
                        return new Date(d.date);
                    };
                    var valueAccessor = function(d) {
                        return +d[dataAttribute];
                    };

                    var line = d3.svg.line()
                        .x(function(d) {
                            return x(keyAccessor(d));
                        })
                        .y(function(d) {
                            return y(valueAccessor(d));
                        })
                        .interpolate('monotone');

                    var svg = d3.select(element[0]).append('svg')
                        .attr('width', width + margin.left + margin.right)
                        .attr('height', height + margin.top + margin.bottom)
                        .append('g')
                        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

                    x.domain(d3.extent(data, keyAccessor));
                    y.domain(d3.extent(data, valueAccessor));

                    svg.append('g')
                        .attr('class', 'x axis')
                        .attr('transform', 'translate(0,' + height + ')')
                        .call(xAxis);

                    svg.append('g')
                        .attr('class', 'y axis')
                        .call(yAxis);

                    svg.append('path')
                        .datum(data)
                        .attr('class', 'line')
                        .attr('d', line);

                    svg.append('g')
                        .selectAll('circle')
                        .data(data)
                        .enter().append('circle')
                        .attr('class', 'data-point')
                        .attr('cx', function(d) {
                            return x(keyAccessor(d));
                        })
                        .attr('cy', function(d) {
                            return y(valueAccessor(d));
                        })
                        .attr('r', 3.5);
                }

            }
        };
    }
]);

'use strict';

angular.module('rooms').directive('streetView', ['$window',
    function($window, $rootScope) {
        return {
            scope: {
                center: '=mapCenter'
            },
            template: '<div></div>',
            restrict: 'A',
            link: function postLink(scope, element, attrs) {

                scope.$on('room_loaded', function(event, room) {
                    var coordinates = room.loc.coordinates;
                    var position = new $window.google.maps.LatLng(coordinates[1], coordinates[0]);
                    var streetview = new $window.google.maps.StreetViewPanorama(element[0], {
                        zoomControl: false,
                        position: position,
                        pov: {
                            heading: 0,
                            pitch: 0,
                            zoom: 1
                        }
                    });

                    var streetViewService = new $window.google.maps.StreetViewService();
                    var streetViewMaxDistance = 50;

                    streetViewService.getPanoramaByLocation(position, streetViewMaxDistance, function(streetViewPanoramaData, status) {
                        if (status === $window.google.maps.StreetViewStatus.OK) {
                            var oldPoint = position;
                            position = streetViewPanoramaData.location.latLng;

                            var heading = $window.google.maps.geometry.spherical.computeHeading(position, oldPoint);

                            setStreetViewSettings(streetview, position, heading);
                        }
                    });

                    function setStreetViewSettings(streetview, pos, heading) {
                        streetview.setPosition(pos);
                        streetview.setPov({
                            heading: heading,
                            zoom: 1,
                            pitch: 0
                        });
                        streetview.setVisible(true);
                    }
                });

            }
        };
    }
]);

'use strict';

angular.module('rooms').factory('Amenity', [ 'gettext',
    function(gettext) {
        return {
            list: function() {
                return [{
                    name: gettext('TV'),
                    value: 'television'
                }, {
                    name: gettext('Internet'),
                    value: 'internet'
                }, {
                    name: gettext('Terras'),
                    value: 'terrace'
                }, {
                    name: gettext('Auto garage'),
                    value: 'parking'
                }, {
                    name: gettext('Fietsstalling'),
                    value: 'bicycleParking'
                }, {
                    name: gettext('Dubbel glas'),
                    value: 'doubleGlass'
                }, {
                    name: gettext('Gemeubeld'),
                    value: 'furnished'
                }, {
                    name: gettext('Aparte badkamer'),
                    value: 'seperateBathroom'
                }, {
                    name: gettext('Aparte keuken'),
                    value: 'seperateKitchen'
                }, {
                    name: gettext('Huisdieren toegelaten'),
                    value: 'pets'
                }, {
                    name: gettext('Domicilie verplicht'),
                    value: 'domicile'
                }];
            }
        };
    }
]);

'use strict';

//Rooms service used to communicate Rooms REST endpoints
angular.module('rooms').factory('Rooms', ['$resource',
    function($resource) {
        return $resource('/api/rooms/:roomId', {
            roomId: '@_id'
        }, {
            update: {
                method: 'PUT'
            },
            getLatestRooms: {
                method: 'GET',
                url: '/api/latestrooms',
                isArray: true
            },
            getMyRooms: {
                method: 'GET',
                url: '/api/myrooms',
                isArray: true
            },
            getRoomsOfSameLocation: {
                method: 'GET',
                url: '/api/rooms/:roomId/same',
                isArray: true
            }
        });
    }
]);

'use strict';

// Setting up route
angular.module('search').config([ 'MetaProvider',
    function(MetaProvider) {
        MetaProvider
          .when('/search/:address', {
            title: 'Huren in :address',
            description: 'Bekijk alle appartementen, huizen en koten in :address'
          });
    }
]);

'use strict';

//Setting up route
angular.module('search')
    .config(['$stateProvider', '$urlRouterProvider',
        function($stateProvider, $urlRouterProvider) {
            // Search state routing
            $stateProvider.
            state('search', {
                url: '/search/:address',
                templateUrl: '/modules/search/views/search.client.view.html'
            })
            .state('search.overlay', {
                url: '/rooms/:roomId/:isOverlay',
                templateUrl: '/modules/rooms/views/view-room.client.view.html'
            });

            $urlRouterProvider.deferIntercept();
        }
    ])
    .run(['$rootScope', '$urlRouter', 'Device',
        function($rootScope, $urlRouter, Device) {
            $rootScope.$on('$locationChangeSuccess', function(e, newUrl, oldUrl) {
                // Prevent $urlRouter's default handler from firing
                e.preventDefault();

                if (!Device.isMobile() && oldUrl.indexOf('/search/') !== -1 && newUrl.indexOf('/l/') !== -1) {
                    console.log('skipping route');
                } else {
                    $urlRouter.sync();
                }

                // Configures $urlRouter's listener *after* your custom listener
                $urlRouter.listen();
            });
        }
    ]);

'use strict';

angular.module('search').controller('SearchController', ['$rootScope', '$scope', '$timeout', '$location', '$state', '$stateParams', 'Geocoder', 'Rooms', '$window', 'Authentication', 'localStorageService', 'Enforcer', 'UserSettings',
    function($rootScope, $scope, $timeout, $location, $state, $stateParams, Geocoder, Rooms, $window, Authentication, localStorageService, Enforcer, UserSettings) {
        $scope.user = Authentication.user;

        $scope.mapCenter = [4.3517100, 50.8503400]; // Brussel
        $scope.mapZoom = 13;
        $scope.filter = {
            location: [],
            proximity: 7000,
            roomType: [],
            minPrice: 0,
            maxPrice: 2000,
            size: null,
            amenities: []
        };
        $scope.results = [];

        $scope.selectedRoomId = null;
        $scope.isOverLayOpen = false;

        var viewedRooms = localStorageService.get('viewedRooms') || [];
        var oldLocation = null;

        $scope.init = function() {
            var urlParamaters = $location.search();

            function getZoomLevel(m) {
                var z = Math.floor((Math.log(20088000 / m)) / Math.log(2));
                if (z > 19) z = 19;
                if (z < 0) z = 0;
                return z;
            }

            // Fixes empty overlay window when clicking browser back button
            $rootScope.$watch(function() {
                return $location.path();
            }, function(newLocation, oldLocation) {
                if (newLocation.indexOf('/search') !== -1 && oldLocation.indexOf('/l/') !== -1) {
                    $scope.selectedRoomId = null;
                }
            });

            if ((!urlParamaters.lat || !urlParamaters.lng) && $stateParams.address) {
                doSearchLookup($stateParams.address);
            } else if (urlParamaters.lat && urlParamaters.lng) {
                parseUrlParameters(urlParamaters);

                $scope.mapCenter = $scope.filter.location;
                $scope.mapZoom = getZoomLevel($scope.filter.proximity);
            } else {
                $scope.mapZoom = 9;
            }

            // Show a room if its in the url
            if ($stateParams.roomId) {
                $scope.selectedRoomId = $stateParams.roomId;
                showRoomOverlay();
            }

            // initial filter save (location)
            if ($scope.user && $scope.user.settings.email.newRooms) {
                $scope.updateSettings();
            }

            // initial rooms fetch
            fetchRooms();

            $rootScope.$on('close_overlay', closeRoomOverlay);

            $scope.$watch('filter', function(newValue, oldValue) {
                if (newValue !== oldValue) {
                    searchFunction();
                }
            }, true);
        };

        function parseUrlParameters(urlParamaters) {
            if (urlParamaters.lat && urlParamaters.lng) $scope.filter.location = [parseFloat(urlParamaters.lng), parseFloat(urlParamaters.lat)];
            if (urlParamaters.proximity) $scope.filter.proximity = urlParamaters.proximity;
            if (urlParamaters.minPrice) $scope.filter.minPrice = +urlParamaters.price;
            if (urlParamaters.maxPrice) $scope.filter.maxPrice = +urlParamaters.maxPrice;
            if (urlParamaters.roomType) $scope.filter.roomType = urlParamaters.roomType;
            if (urlParamaters.size) $scope.filter.size = +urlParamaters.size;
            if (urlParamaters.amneties) $scope.filter.amneties = urlParamaters.amneties;
        }

        function doSearchLookup(address) {
            Geocoder.geocodeAddress(address).then(function(result) {
                $scope.mapCenter = [result.lng, result.lat];
                $scope.filter.proximity = result.proximity;
            });
        }

        $scope.mapChangedEvent = function(result) {
            $scope.filter.proximity = result.proximity / 2;
            $scope.filter.location = [result.lng, result.lat];

            $location.search('lat', result.lat).search('lng', result.lng).search('proximity', $scope.filter.proximity);

            // Prevent digest errors
            $timeout(function() {
                $scope.$apply();
            });
        };

        $scope.toggleAmenitySelection = function(amenity) {
            var idx = $scope.filter.amenities.indexOf(amenity);

            if (idx > -1) {
                $scope.filter.amenities.splice(idx, 1);
            } else {
                $scope.filter.amenities.push(amenity);
            }
        };

        $scope.selectRoom = function(roomId, url) {

            if (!$scope.selectedRoomId || $scope.selectedRoomId !== roomId) {
                $scope.selectedRoomId = roomId;

                $window._.extend($stateParams, {
                    roomId: roomId,
                    isOverlay: true
                });

                // remember the url of the search map and set the new url to the room
                var currentUrl = $location.url();
                if (currentUrl.indexOf('/search') !== -1) {
                    oldLocation = $location.url();
                    $location.url(url);
                }

                showRoomOverlay();

                if (viewedRooms.indexOf(roomId) === -1) viewedRooms.push(roomId);

            } else {
                $scope.selectedRoomId = null;

                closeRoomOverlay();
            }
        };

        $scope.hasSeenRoom = function(roomId) {
            return viewedRooms.indexOf(roomId) !== -1;
        };

        $scope.openRoomPopup = function(roomId) {
            $scope.$broadcast('open_marker_popup', roomId);
        };

        $scope.getRoomTypeIcon = function(roomType) {
            if (roomType === 'room') return 'lodging';
            else if (roomType === 'appartment') return 'commercial';
            else return 'building';
        };

        $scope.setRoomType = function(selection) {
            if (selection === 'all') return [];
            else return [selection];
        };

        $scope.isNewRoom = function(room) {
            return (new Date().getTime() - new Date(room.created).getTime()) < 86400000; // one day
        };

        // Update user profile
        $scope.updateSettings = function($event) {
            Enforcer.do(function() {
                UserSettings.set('alert.filters', {
                    location: $scope.filter.location,
                    proximity: $scope.filter.proximity
                });
            }, function() {
                $event.preventDefault();
            });
        };

        function fetchRooms() {
            Rooms.query($scope.filter, function(results) {

                // Non-destructively rebuild the array of rooms, otherwise all the markers would
                // be replaced and popups would be closed, confusing the user

                var oldRooms = $scope.results;
                var newRooms = results;

                var oldIds = oldRooms.map(function(room) {
                    return room._id;
                });
                var newIds = newRooms.map(function(room) {
                    return room._id;
                });

                var toDelete = $window._.difference(oldIds, newIds);
                var toAdd = $window._.difference(newIds, oldIds);

                oldRooms = oldRooms.filter(function(room) {
                    return !$window._.contains(toDelete, room._id);
                });

                newRooms.forEach(function(room) {
                    if ($window._.contains(toAdd, room._id)) oldRooms.push(room);
                });

                $scope.results = oldRooms;

                $scope.htmlReady(); 
            });
        }

        function closeRoomOverlay() {
            $state.transitionTo('search', $stateParams, {
                reload: false,
                location: false
            });

            // restore the original url of the search map
            if (oldLocation) {
                $location.url(oldLocation);
                oldLocation = null;
            }

            $scope.selectedRoomId = null;
            $scope.isOverLayOpen = false;
        }

        function showRoomOverlay() {
            $state.transitionTo('search.overlay', $stateParams, {
                reload: false,
                location: false
            });
            $scope.$broadcast('close_marker_popups');

            $scope.isOverLayOpen = true;
        }

        var searchFunction = $window._.debounce(fetchRooms, 400);

    }
]);

'use strict';

angular.module('search').directive('checkboxGroup', ['$window',
    function($window) {
        return {
            require: 'ngModel',
            restrict: 'A',
            scope: {
                model: '=ngModel'
            },
            link: function postLink(scope, element, attrs) {

                var buttons = element.children('button');

                buttons.bind('click', function(e) {
                    var el = $window.$(e.currentTarget);
                    var val = el.attr('data-val');
                    var index = scope.model.indexOf(val);

                    if (el.hasClass('active')) {
                        if (index !== -1) scope.model.splice(index, 1);
                        el.removeClass('active');
                    } else {
                        if (index === -1) scope.model.push(val);
                        el.addClass('active');
                    }

                    e.stopPropagation();
                });

            }
        };
    }
]);

'use strict';

angular.module('search').directive('mapboxMap', ['$compile', '$q', '$window', '$http', '$timeout',
    function($compile, $q, $window, $http, $timeout) {

        var _mapboxMap;

        return {
            restrict: 'E',
            transclude: true,
            replace: true,
            scope: {
                center: '=mapCenter',
                zoom: '=mapZoom',
                changedEvent: '=mapChanged',
                preventPopups: '=',
                selectRoom: '='
            },
            template: '<div class="map-canvas" ng-transclude></div>',

            link: function(scope, element, attrs) {

                var options = {
                    minZoom: 11
                };

                scope.map = $window.L.mapbox.map(element[0], 'defreek.j27p0821', options)
                    .setView([scope.center[1], scope.center[0]], scope.zoom);

                _mapboxMap.resolve(scope.map);

                scope.isClusteringMarkers = attrs.clusterMarkers !== undefined;

                var shouldRefitMap = attrs.scaleToFit !== undefined;
                scope.fitMapToMarkers = function() {
                    if (!shouldRefitMap) return;
                    // TODO: only call this after all markers have been added, instead of per marker add

                    var group = new $window.L.featureGroup(scope.markers);
                    scope.map.fitBounds(group.getBounds());
                };

                var foursquareMarkers = new $window.L.featureGroup().addTo(scope.map);

                if (scope.changedEvent) {
                    scope.map.on('moveend', function(e) {
                        var center = scope.map.getCenter();

                        scope.changedEvent({
                            lng: center.lng,
                            lat: center.lat,
                            proximity: getBoundsDistance()
                        });

                        foursquareMarkers.clearLayers();
                        getFoursquareData();
                    });
                }

                scope.$on('open_marker_popup', function(event, id) {
                    if (!scope.preventPopups) openMarkerPopupById(id);
                });

                scope.$on('close_marker_popups', function(event) {
                    scope.markers.forEach(function(marker) {
                        marker.closePopup();
                    });
                });

                scope.$watch('center', function() {
                    scope.map.setView([scope.center[1], scope.center[0]], scope.zoom);
                });

                scope.map.on('popupopen', function(e) {
                    var popup = angular.element(document.getElementsByClassName('leaflet-popup-content'));
                    $compile(popup)(scope);

                    $timeout(function() {
                        scope.$apply();
                    });

                });

                scope.$on('$destroy', function() {
                    scope.map.remove();
                });

                function openMarkerPopupById(roomId) {
                    scope.markers.forEach(function(marker) {
                        if (marker.roomId === roomId) {
                            marker.openPopup();
                        }
                    });
                }

                function getBoundsDistance() {
                    var bounds = scope.map.getBounds();
                    var northWest = bounds.getNorthWest();
                    var southEast = bounds.getSouthEast();

                    return Math.floor(northWest.distanceTo(southEast));
                }

                function getFoursquareData() {
                    var center = scope.map.getCenter();

                    var params = {
                        client_id: '4I5SHYQHG4OXY2ZCCRTFPNYFVK0U0G4NPLIBKLWGM2SWLPVY',
                        client_secret: '11YEGLXWQBXX4KERSY2CXLMC4E3C2X021DGZLXVVMK0KRWJZ',
                        ll: center.lat + ',' + center.lng,
                        radius: getBoundsDistance(),
                        v: '20140701',
                        categoryId: '4bf58dd8d48988d1ae941735' // university category
                    };

                    $http({
                        url: 'https://api.foursquare.com/v2/venues/search',
                        method: 'GET',
                        params: params
                    }).success(function(result) {
                        result.response.venues.forEach(function(venue) {

                            var latlng = $window.L.latLng(venue.location.lat, venue.location.lng);
                            var marker = $window.L.marker(latlng, {
                                    icon: $window.L.divIcon({
                                        className: 'maki-icon college'
                                    })
                                })
                                .bindPopup('<a target="_blank" href="https://foursquare.com/v/' + venue.id + '">' + venue.name + '</a>')
                                .addTo(foursquareMarkers);

                        });
                    });

                }

                getFoursquareData();

            },
            controller: ['$scope', function($scope) {
                $scope.markers = [];
                $scope.featureLayers = [];

                _mapboxMap = $q.defer();
                $scope.getMap = this.getMap = function() {
                    return _mapboxMap.promise;
                };

                if ($window.L.MarkerClusterGroup) {
                    $scope.clusterGroup = new $window.L.MarkerClusterGroup({
                        showCoverageOnHover: false
                    });
                    this.getMap().then(function(map) {
                        map.addLayer($scope.clusterGroup);
                    });
                }

                this.$scope = $scope;
            }]
        };
    }
]);

'use strict';

angular.module('search').directive('mapboxMarker', ['$compile', '$window',
    function($compile, $window) {

        var _colors = {
            navy: '#001f3f',
            blue: '#0074d9',
            aqua: '#7fdbff',
            teal: '#39cccc',
            olive: '#3d9970',
            green: '#2ecc40',
            lime: '#01ff70',
            yellow: '#ffdc00',
            orange: '#ff851b',
            red: '#ff4136',
            fuchsia: '#f012be',
            purple: '#b10dc9',
            maroon: '#85144b',
            white: 'white',
            silver: '#dddddd',
            gray: '#aaaaaa',
            black: '#111111'
        };

        return {
            restrict: 'E',
            require: '^mapboxMap',
            transclude: true,
            scope: true,
            replace: true,
            link: function(scope, element, attrs, controller, transclude) {
                var opts = {
                    draggable: attrs.draggable !== undefined
                };

                var marker;

                function setStyleOptions(attrs, default_opts) {
                    var opts = default_opts || {};
                    if (attrs.size) {
                        opts['marker-size'] = attrs.size;
                    }
                    if (attrs.color) {
                        if (attrs.color[0] === '#') {
                            opts['marker-color'] = attrs.color;
                        } else {
                            opts['marker-color'] = _colors[attrs.color] || attrs.color;
                        }
                    }
                    if (attrs.icon) {
                        opts['marker-symbol'] = attrs.icon;
                    }
                    return opts;
                }

                var style = setStyleOptions(attrs);

                var addMarker = function(map, attrs, popupContent, opts, style) {
                    opts = opts || {};

                    var marker = $window.L.mapbox.marker.style({
                        properties: style
                    }, [attrs.lat, attrs.lng]);
                    if (popupContent && popupContent.length > 0) {
                        marker.bindPopup(popupContent, {
                            closeButton: false,
                            minWidth: 320
                        });
                        // application specific
                        marker.roomId = attrs.roomId;
                    }

                    if (controller.$scope.isClusteringMarkers && opts.excludeFromClustering !== true) {
                        controller.$scope.clusterGroup.addLayer(marker);
                    } else {
                        marker.addTo(map);
                    }

                    // this needs to come after being added to map because the L.mapbox.marker.style() factory
                    // does not let us pass other opts (eg, draggable) in
                    if (opts.draggable) marker.dragging.enable();

                    controller.$scope.markers.push(marker);
                    //controller.$scope.fitMapToMarkers();

                    return marker;
                };

                var addCurrentLocation = function(map, popupContent, opts, style) {
                    style = setStyleOptions(style, {
                        'marker-color': '#000',
                        'marker-symbol': 'star'
                    });
                    opts.excludeFromClustering = true;

                    map.on('locationfound', function(e) {
                        marker = addMarker(map, [e.latlng.lat, e.latlng.lng], null, opts, style);
                    });

                    map.locate();
                };

                controller.getMap().then(function(map) {

                    setTimeout(function() {
                        // there's got to be a better way to programmatically access transcluded content
                        var popupHTML = '';

                        var transcluded = transclude(scope, function() {});

                        for (var i = 0; i < transcluded.length; i++) {
                            if (transcluded[i].outerHTML !== undefined) popupHTML += transcluded[i].outerHTML;
                        }

                        if (attrs.currentLocation !== undefined) {
                            addCurrentLocation(map, null, opts, style);
                        } else {
                            if (popupHTML) {
                                var popup = angular.element(popupHTML);
                                $compile(popup)(scope);

                                if (!scope.$$phase) scope.$digest();

                                var newPopupHTML = '';
                                for (i = 0; i < popup.length; i++) {
                                    newPopupHTML += popup[i].outerHTML;
                                }

                                marker = addMarker(map, attrs, newPopupHTML, opts, style);
                            } else {
                                marker = addMarker(map, attrs, null, opts, style);
                            }

                            element.bind('$destroy', function() {
                                if (controller.$scope.isClusteringMarkers) {
                                    controller.$scope.clusterGroup.removeLayer(marker);
                                } else {
                                    map.removeLayer(marker);
                                }
                            });
                        }
                    }, 0);

                });
            }
        };
    }
]);

'use strict';

angular.module('search').directive('radioGroup', ['$window', '$timeout',
    function($window, $timeout) {
        return {
            require: 'ngModel',
            restrict: 'A',
            scope: {
                model: '=ngModel',
                outputFunction: '='
            },
            link: function postLink(scope, element, attrs) {

                var buttons = element.children('button');
                var active = element.children('button.active');

                function setModel(data) {
                    scope.model = scope.outputFunction ? scope.outputFunction(data) : data;

                    $timeout(function() {
                        scope.$apply();
                    });
                }

                setModel(active.attr('data-val'));

                buttons.bind('click', function(e) {
                    var el = $window.$(e.currentTarget);

                    if (!el.hasClass('active')) {
                        buttons.removeClass('active');
                        el.addClass('active');
                    }

                    setModel(el.attr('data-val'));

                    e.stopPropagation();
                });
            }
        };
    }
]);

'use strict';

angular.module('search').directive('rangeSlider', ['$window',
    function($window) {
        return {
            restrict: 'A',
            scope: {
                start: '@',
                step: '@',
                end: '@',
                callback: '@',
                margin: '@',
                ngModel: '=',
                ngFrom: '=',
                ngTo: '='
            },
            link: function(scope, element, attrs) {
                var callback, fromParsed, parsedValue, slider, toParsed;
                slider = $window.$(element);
                callback = scope.callback ? scope.callback : 'slide';
                if (scope.ngFrom !== null && scope.ngTo !== null) {
                    fromParsed = null;
                    toParsed = null;
                    slider.noUiSlider({
                        start: [
                            scope.ngFrom || scope.start,
                            scope.ngTo || scope.end
                        ],
                        step: parseFloat(scope.step || 1),
                        connect: true,
                        margin: parseFloat(scope.margin || 0),
                        range: {
                            min: [parseFloat(scope.start)],
                            max: [parseFloat(scope.end)]
                        }
                    });
                    slider.on(callback, function() {

                        var _ref = slider.val();
                        var from = _ref[0];
                        var to = _ref[1];
                        fromParsed = parseFloat(from);
                        toParsed = parseFloat(to);
                        return scope.$apply(function() {
                            scope.ngFrom = fromParsed;
                            scope.ngTo = toParsed;
                            return toParsed;
                        });
                    });
                    scope.$watch('ngFrom', function(newVal, oldVal) {
                        if (newVal !== fromParsed) {
                            return slider.val([
                                newVal,
                                null
                            ]);
                        }
                    });
                    return scope.$watch('ngTo', function(newVal, oldVal) {
                        if (newVal !== toParsed) {
                            return slider.val([
                                null,
                                newVal
                            ]);
                        }
                    });
                } else {
                    parsedValue = null;
                    slider.noUiSlider({
                        start: [scope.ngModel || scope.start],
                        step: parseFloat(scope.step || 1),
                        range: {
                            min: [parseFloat(scope.start)],
                            max: [parseFloat(scope.end)]
                        }
                    });
                    slider.on(callback, function() {
                        parsedValue = parseFloat(slider.val());
                        return scope.$apply(function() {
                            scope.ngModel = parsedValue;
                            return parsedValue;
                        });
                    });
                    return scope.$watch('ngModel', function(newVal, oldVal) {
                        if (newVal !== parsedValue) {
                            return slider.val(newVal);
                        }
                    });
                }
            }
        };
    }
]);

/*
 * An AngularJS Service for intelligently geocoding addresses using Google's API. Makes use of
 * localStorage (via the ngStorage package) to avoid unnecessary trips to the server. Queries
 * Google's API synchronously to avoid `google.maps.GeocoderStatus.OVER_QUERY_LIMIT`.
 *
 * @author: benmj
 * @author: amir.valiani
 *
 * Original source: https://gist.github.com/benmj/6380466
 */

/*global angular: true, google: true, _ : true */

'use strict';

angular.module('core').factory('Geocoder', ['localStorageService', '$q', '$timeout', '$rootScope',
    function($localStorage, $q, $timeout, $rootScope) {
        var locations = $localStorage.get('locations') ? $localStorage.get('locations') : {};
        //$localStorage.locations ? JSON.parse($localStorage.locations) : {};

        var queue = [];

        // Amount of time (in milliseconds) to pause between each trip to the
        // Geocoding API, which places limits on frequency.
        var QUERY_PAUSE = 250;

        /**
         * executeNext() - execute the next function in the queue.
         *                  If a result is returned, fulfill the promise.
         *                  If we get an error, reject the promise (with message).
         *                  If we receive OVER_QUERY_LIMIT, increase interval and try again.
         */
        var executeNext = function() {
            var task = queue[0],
                geocoder = new google.maps.Geocoder();

            geocoder.geocode({
                address: task.address
            }, function(result, status) {

                if (status === google.maps.GeocoderStatus.OK) {

                    var parsedResult = {
                        lat: result[0].geometry.location.lat(),
                        lng: result[0].geometry.location.lng(),
                        formattedAddress: result[0].formatted_address,
                        accuracy: result[0].address_components.length
                    };

                    for (var i = 0; i < result[0].address_components.length; i++) {
                        var type = result[0].address_components[i].types[0];
                        switch (type) {
                            case 'street_number':
                                parsedResult.streetNumber = result[0].address_components[i].long_name;
                                break;
                            case 'route':
                                parsedResult.street = result[0].address_components[i].long_name;
                                break;
                            case 'locality':
                                parsedResult.city = result[0].address_components[i].long_name;
                                break;
                            case 'country':
                                parsedResult.country = result[0].address_components[i].long_name;
                                break;
                        }
                    }

                    locations[task.address] = parsedResult;

                    //$localStorage.locations = JSON.stringify(locations);
                    $localStorage.set('locations', locations);

                    queue.shift();
                    task.d.resolve(parsedResult);

                } else if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                    queue.shift();
                    task.d.reject({
                        type: 'zero',
                        message: 'Zero results for geocoding address ' + task.address
                    });
                } else if (status === google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
                    if (task.executedAfterPause) {
                        queue.shift();
                        task.d.reject({
                            type: 'busy',
                            message: 'Geocoding server is busy can not process address ' + task.address
                        });
                    }
                } else if (status === google.maps.GeocoderStatus.REQUEST_DENIED) {
                    queue.shift();
                    task.d.reject({
                        type: 'denied',
                        message: 'Request denied for geocoding address ' + task.address
                    });
                } else {
                    queue.shift();
                    task.d.reject({
                        type: 'invalid',
                        message: 'Invalid request for geocoding: status=' + status + ', address=' + task.address
                    });
                }

                if (queue.length) {
                    if (status === google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
                        var nextTask = queue[0];
                        nextTask.executedAfterPause = true;
                        $timeout(executeNext, QUERY_PAUSE);
                    } else {
                        $timeout(executeNext, 0);
                    }
                }

                if (!$rootScope.$$phase) {
                    $rootScope.$apply();
                }
            });
        };

        return {
            geocodeAddress: function(address) {
                var d = $q.defer();

                if (_.has(locations, address)) {
                    d.resolve(locations[address]);
                } else {
                    queue.push({
                        address: address,
                        d: d
                    });

                    if (queue.length === 1) {
                        executeNext();
                    }
                }

                return d.promise;
            }
        };
    }
]);

'use strict';

// Config HTTP Error Handling
angular.module('users').config(['$httpProvider',
    function($httpProvider) {
        // Set the httpProvider "not authorized" interceptor
        $httpProvider.interceptors.push(['$q', '$location', 'Authentication',
            function($q, $location, Authentication) {
                return {
                    responseError: function(rejection) {
                        switch (rejection.status) {
                            case 401:
                                // Deauthenticate the global user
                                Authentication.user = null;

                                // Redirect to signin page
                                $location.path('signin');
                                break;
                            case 403:
                                // Add unauthorized behaviour
                                break;
                        }

                        return $q.reject(rejection);
                    }
                };
            }
        ]);
    }
]);

'use strict';

// Setting up route
angular.module('users').config([ 'MetaProvider',
    function(MetaProvider) {
        MetaProvider
          .when('/settings/profile', {
            title: '1Roof - Profiel'
          })

          .when('/settings/password', {
            title: '1Roof - Wachtwoord'
          })

          .when('/signup', {
            title: '1Roof - Registreren'
          })

          .when('/signin', {
            title: '1Roof - Inloggen'
          })

          .when('/forgot', {
            title: '1Roof - Wachtwoord vergeten'
          })

          .when('/reset/:token', {
            title: '1Roof - Wachtwoord resetten'
          })

          .when('/dashboard/:nav', {
            title: '1Roof - Dashboard'
          })

          .when('/dashboard/messages/:inboxId', {
            title: '1Roof - Berichten'
          })

          .when('/users/:userId/favorites', {
            title: '1Roof - Wishlist bekijken'
          });

    }
]);

'use strict';

// Setting up route
angular.module('users').config(['$stateProvider',
    function($stateProvider) {
        // Users state routing
        $stateProvider.
        state('profile', {
            url: '/settings/profile',
            templateUrl: '/modules/users/views/settings/edit-profile.client.view.html'
        }).
        state('password', {
            url: '/settings/password',
            templateUrl: '/modules/users/views/settings/change-password.client.view.html'
        }).
        state('accounts', {
            url: '/settings/accounts',
            templateUrl: '/modules/users/views/settings/social-accounts.client.view.html'
        }).
        state('signup', {
            url: '/signup',
            templateUrl: '/modules/users/views/signup.client.view.html'
        }).
        state('signin', {
            url: '/signin',
            templateUrl: '/modules/users/views/signin.client.view.html'
        }).
        state('forgot', {
            url: '/forgot',
            templateUrl: '/modules/users/views/forgot.client.view.html'
        }).
        state('reset', {
            url: '/reset/:token',
            templateUrl: '/modules/users/views/reset.client.view.html'
        }).
        state('dashboard', {
            url: '/dashboard/:nav',
            templateUrl: '/modules/users/views/dashboard.client.view.html'
        }).
        state('viewInbox', {
            url: '/dashboard/messages/:inboxId',
            templateUrl: '/modules/users/views/inbox.client.view.html',
            reloadOnSearch: false
        }).
        state('favorites', {
            url: '/users/:userId/favorites',
            templateUrl: '/modules/users/views/favorites.client.view.html'
        });
    }
]);

'use strict';

angular.module('users').controller('AuthenticationController', ['$rootScope', '$scope', '$stateParams', '$http', '$location', '$q', 'Authentication', 'Modal',
    function($rootScope, $scope, $stateParams, $http, $location, $q, Authentication, Modal) {
        $scope.authentication = Authentication;

        $scope.busy = false;
        $scope.success = false;

        //If user is signed in then redirect back home
        if ($scope.authentication.user) $location.path('/');

        $scope.signup = function() {
            var deferred = $q.defer();

            $scope.busy = true;

            $http.post('/auth/signup', $scope.credentials).success(function(response) {
                // If successful we assign the response to the global user model
                $scope.authentication.user = response;

                // CLose the modal if there is one
                if ($scope.$close) $scope.$close();

                deferred.resolve();

                $rootScope.$broadcast('logged_in');

                $scope.busy = false;

                return deferred.promise;
            }).error(function(response) {
                $scope.error = response.message;
                deferred.reject();

                $scope.busy = false;

                return deferred.promise;
            });
        };

        $scope.signin = function() {
            var deferred = $q.defer();

            $scope.busy = true;

            $http.post('/auth/signin', $scope.credentials).success(function(response) {
                // If successful we assign the response to the global user model
                $scope.authentication.user = response;

                // CLose the modal if there is one
                if ($scope.$close) $scope.$close();

                deferred.resolve();

                $rootScope.$broadcast('logged_in');

                $scope.busy = false;

                return deferred.promise;
            }).error(function(response) {
                $scope.error = response.message;
                deferred.reject();

                $scope.busy = false;

                return deferred.promise;
            });
        };

        $scope.forgot = function() {
            $scope.success = $scope.error = null;

            $scope.busy = true;

            $http.post('/auth/forgot', $scope.credentials).success(function(response) {
                // Show user success message and clear form
                $scope.credentials = null;
                $scope.success = true;

                $scope.busy = false;
            }).error(function(response) {
                // Show user error message and clear form
                $scope.credentials = null;
                $scope.error = response.message;

                $scope.busy = false;
            });
        };

        // Change user password
        $scope.reset = function() {
            $scope.success = $scope.error = null;

            $scope.busy = true;

            $http.post('/auth/reset/' + $stateParams.token, $scope.passwordDetails).success(function(response) {
                // If successful show success message and clear form
                $scope.success = true;
                $scope.passwordDetails = null;

                $scope.busy = false;
            }).error(function(response) {
                $scope.error = response.message;

                $scope.busy = false;
            });
        };

        $scope.openSignupModal = function() {
            if ($scope.$dismiss) $scope.$dismiss();
            Modal.signup();
        };

        $scope.openSigninModal = function() {
            if ($scope.$dismiss) $scope.$dismiss();
            Modal.signin();
        };
    }
]);

'use strict';

angular.module('users').controller('DashboardController', ['$scope', '$stateParams', '$state', '$location', 'Rooms', 'Authentication',
    function($scope, $stateParams, $state, $location, Rooms, Authentication) {
        $scope.authentication = Authentication;
        $scope.nav = 'rooms';

        // If user is not signed in then redirect back home
        if (!Authentication.user) $location.path('/signin');

        // Init
        $scope.init = function() {
            if ($stateParams.nav) $scope.nav = $stateParams.nav;

            $scope.htmlReady(); 
        };

        $scope.getMyRooms = function() {
            $scope.myrooms = Rooms.getMyRooms();
        };

        $scope.setTab = function(tab) {
            $scope.nav = tab;
            $location.path('/dashboard/' + tab);
        };

        $scope.goToRoom = function(roomId) {
            $location.path('/rooms/' + roomId);
        };

        $scope.visibilityText = function(item) {
            return item ? 'online' : 'offline';
        };

        $scope.updateRoom = function(room) {
            room.$update();
        };

        $scope.viewAnalytics = function(room) {
            $location.path('/rooms/' + room._id + '/analytics');
            
            // if (Authentication.user.subscription.plan !== 'BUSINESS') {
            //     $state.transitionTo('pricing', {
            //         message: 'analytics'
            //     });
            // } else {
            //     $location.path('/rooms/' + room._id + '/analytics');
            // }
        };
    }
]);

'use strict';

angular.module('users').controller('FavoritesController', ['$scope', '$http', '$stateParams', 'Authentication', 'Meta',
    function($scope, $http, $stateParams, Authentication, Meta) {
        $scope.authentication = Authentication;
        $scope.favorites = [];

        $scope.busy = false;

        $scope.init = function() {
            $http.get('/api/users/' + $stateParams.userId).success(function(response) {
                $scope.user = response;

                Meta.add('/l/:roomId/:city/:title', { 
                    title: 'Wishlist van ' + $scope.user.displayName
                });

                getUserFavorites();
            });
        };


        function getUserFavorites() {
            $http.get('/api/users/' + $scope.user._id + '/favorites').success(function(response) {
                $scope.favorites = response;
                $scope.busy = false;

                $scope.htmlReady(); 
            }).error(function(response) {
                $scope.busy = false;

                $scope.htmlReady(); 
            });
        }

    }
]);

'use strict';

angular.module('users').controller('InboxController', ['$rootScope', '$scope', '$location', '$http', '$stateParams', 'Inbox', 'Authentication', 'Socket', 'Modal',
    function($rootScope, $scope, $location, $http, $stateParams, Inbox, Authentication, Socket, Modal) {
        $scope.authentication = Authentication;
        $scope.newMessage = '';
        $scope.busy = false;

        // If user is not signed in then redirect back home
        if (!Authentication.user) $location.path('/signin');

        $scope.init = function() {
            $scope.findOne($stateParams.inboxId);

            // subscribe to this inbox session
            $scope.inbox.$promise.then(function(inbox) {
                Socket.emit('join', inbox._id);
            });

            // leave this inbox session
            $scope.$on('$destroy', function() {
                Socket.emit('leave', $scope.inbox._id);
            });

            // instantly recieve new messages
            Socket.on('newMessage', function(message) {
                $scope.inbox.messages.push(message);
                // playNewMessageSound();
            });
        };

        $scope.list = function() {
            $scope.inboxes = Inbox.query();
        };

        // Find existing Inbox
        $scope.findOne = function(inboxId) {
            $scope.inboxes = Inbox.query();
            $scope.inbox = Inbox.get({
                inboxId: inboxId
            }, function(inbox) {
                var unreadMessageCount = $scope.unreadMessages(inbox);
                if (unreadMessageCount > 0) {
                    setInboxAsRead(inbox);

                    $rootScope.$broadcast('inbox_read', unreadMessageCount);
                }

            });
        };

        $scope.sendMessage = function() {
            if (!$scope.newMessage || $scope.newMessage === '') return;

            $scope.busy = true;

            $http.post('/api/inbox/' + $scope.inbox._id + '/sendmessage', {
                message: $scope.newMessage
            }).success(function(response) {
                $scope.busy = false;
                $scope.newMessage = '';
                // $scope.inbox.messages.push(response);
            }).error(function(response) {
                $scope.busy = false;
            });
        };

        $scope.isMessageOwner = function(message) {
            return message.sender === Authentication.user._id;
        };

        $scope.showInbox = function(inboxId) {
            $scope.findOne(inboxId);

            $location.path('/dashboard/messages/' + inboxId);
        };

        $scope.getUserPicture = function(inbox) {
            var user = inbox.sender._id === Authentication.user._id ? inbox.roomOwner : inbox.sender;

            var pictureSrc = '';

            if (user.provider === 'local')
                pictureSrc = '/modules/core/img/default-user-icon.png';
            else if (user.provider === 'google')
                pictureSrc = user.providerData.picture;
            else if (user.provider === 'facebook')
                pictureSrc = 'https://graph.facebook.com/' + user.providerData.id + '/picture?type=normal';

            return {
                'background-image': 'url(' + pictureSrc + ')'
            };
        };

        $scope.getLastMessage = function(inbox) {
            return inbox.messages[inbox.messages.length - 1];
        };

        $scope.unreadMessages = function(inbox) {
            var count = 0;
            for (var i = 0; i < inbox.messages.length; i++) {
                var message = inbox.messages[i];
                if (message.sender !== Authentication.user._id && !message.isRead) count++;
            }
            return count;
        };

        $scope.deleteInbox = function(inbox, $index, $event) {
            Modal.confirm('inbox').then(function() {
                inbox.$remove(function() {
                    $scope.inboxes.splice($index, 1);
                });
            });
            $event.preventDefault();
        };

        function setInboxAsRead(inbox) {
            inbox.messages.forEach(function(message) {
                if (message.sender !== Authentication.user._id) message.isRead = true;
            });
            inbox.$update();
        }

        function playNewMessageSound() {
            var audio = new Audio('/modules/core/img/woosh.wav');
            audio.play();
        }

    }
]);

'use strict';

angular.module('users').controller('SettingsController', ['$scope', '$http', '$location', '$stateParams', 'Users', 'Authentication', 'gettext', 'Modal',
    function($scope, $http, $location, $stateParams, Users, Authentication, gettext, Modal) {
        $scope.user = Authentication.user;
        $scope.busy = false;
        $scope.nav = 'info';

        // If user is not signed in then redirect back home
        if (!$scope.user) $location.path('/signin');

        // Check if there are additional accounts
        $scope.hasConnectedAdditionalSocialAccounts = function(provider) {
            for (var i in $scope.user.additionalProvidersData) {
                return true;
            }

            return false;
        };

        // Check if provider is already in use with current user
        $scope.isConnectedSocialAccount = function(provider) {
            return $scope.user.provider === provider || ($scope.user.additionalProvidersData && $scope.user.additionalProvidersData[provider]);
        };

        // Remove a user social account
        $scope.removeUserSocialAccount = function(provider) {
            $scope.success = $scope.error = null;

            $http.delete('/api/users/accounts', {
                params: {
                    provider: provider
                }
            }).success(function(response) {
                // If successful show success message and clear form
                $scope.success = true;
                $scope.user = Authentication.user = response;
            }).error(function(response) {
                $scope.error = response.message;
            });
        };

        // Update a user profile
        $scope.updateUserProfile = function() {
            $scope.success = $scope.error = null;
            var user = new Users($scope.user);

            user.$update(function(response) {
                $scope.success = true;
                Authentication.user = response;
            }, function(response) {
                $scope.error = response.data.message;
            });
        };

        // Change user password
        $scope.changeUserPassword = function() {
            $scope.success = $scope.error = null;

            $http.post('/api/users/password', $scope.passwordDetails).success(function(response) {
                // If successful show success message and clear form
                $scope.success = true;
                $scope.passwordDetails = null;
            }).error(function(response) {
                $scope.error = response.message;
            });
        };

        $scope.getSubscription = function() {
            // TODO: request this from the API
            var plan = Authentication.user.subscription.plan;

            if (plan === 'FREE') return gettext('Student');
            else if (plan === 'PRO') return gettext('Huisbaas');
            else if (plan === 'BUSINESS') return gettext('Agentschap');
        };

        $scope.removeAccount = function() {
            Modal.confirm('account').then(function() {
                var user = new Users($scope.user);

                user.$remove(function() {
                    $location.path('/');
                });
            });
        };
    }
]);

'use strict';

angular.module('users').directive('parallax', ['$window',
    function($window) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var offset = Number(attrs.offset) || 0;
                element.css('background-position', 'left ' + (offset) + 'px');

                $window.$($window).scroll(function() {
                    var scrolledY = $window.$($window).scrollTop();
                    console.log(scrolledY);
                    console.log(offset);
                    element.css('background-position', 'left ' + (scrolledY + offset) + 'px');
                });
            }
        };
    }
]);

'use strict';

angular.module('users').directive('scrollBottom', ['$timeout',
    function($timeout) {
        return {
            require: 'ngModel',
            scope: {
                model: '=ngModel'
            },
            restrict: 'A',
            link: function(scope, $el, attrs) {
                var el = $el[0];

                function scrollToBottom() {
                    el.scrollTop = el.scrollHeight;
                }

                scope.$parent.$on('messages_rendered', function() {
                    $timeout(function() {
                        scrollToBottom();
                    }, 100);
                });
                scope.$watch('model', function(newValue, oldValue) {
                    if (newValue) scrollToBottom();
                });
            }
        };
    }
]);

'use strict';

angular.module('core').directive('userPicture', [

    function() {
        return {
            restriction: 'A',
            scope: {
                userModel: '='
            },
            link: function(scope, element, attrs) {

                var url = '';

                scope.$watch('userModel', function(newVal) {
                    if (newVal) {
                        element.css({
                            'background-image': 'url(' + getUserPicture(newVal) + ')'
                        });
                    }
                });

                function getUserPicture(user) {

                    if (user.provider === 'google')
                        return user.providerData.picture;
                    else if (user.provider === 'facebook')
                        return 'https://graph.facebook.com/' + user.providerData.id + '/picture?type=normal';
                    else return '/modules/core/img/default-user-icon.png';

                }

            }
        };
    }
]);

'use strict';

// Authentication service for user variables
angular.module('users').factory('Authentication', [

    function() {
        var _this = this;

        _this._data = {
            user: window.user
        };

        return _this._data;
    }
]);

'use strict';

// Enforce user singup before callback
angular.module('users').service('Enforcer', ['Authentication', 'Modal',
    function(Authentication, Modal) {

        this.do = function(success, failure) {
            if (!Authentication.user) {
                Modal.signup().then(success, failure);
            } else {
                success();
            }
        };

    }
]);

'use strict';

angular.module('users').factory('Inbox', ['$resource',
    function($resource) {
        return $resource('/api/inbox/:inboxId', {
            inboxId: '@_id'
        }, {
            update: {
                method: 'PUT'
            },
            sendMessage: {
                method: 'POST',
                url: '/api/inbox/:inboxId/sendmessage'
            }
        });
    }
]);

'use strict';

// Enforce user singup before callback
angular.module('users').service('UserSettings', ['Authentication', 'Users',
    function(Authentication, Users) {
        var user = Authentication.user;

        this.set = function(property, value, callback) {
            setProperty(user.settings, property, value);

            save(callback);
        };

        this.get = function(property) {
            return user.settings[property];
        };

        function save(callback) {
            var usr = new Users(user);

            usr.$update(function(response) {
                user = response;

                if (callback) callback(user);
            });
        }

        function setProperty(obj, path, value) {
            var tags = path.split('.'),
                len = tags.length - 1;
            var current = tags[0];

            for (var i = 0; i < len; i++) {
                current = tags[i];

                if (obj[tags[i]] === undefined) {
                    obj[tags[i]] = {};
                }
            }

            if (tags.length === 1) obj[current] = value;
            else obj[current][tags[len]] = value;

            user.settings = obj;
        }

    }
]);

'use strict';

// Users service used for communicating with the users REST endpoint
angular.module('users').factory('Users', ['$resource',
    function($resource) {
        return $resource('/api/users', {}, {
            update: {
                method: 'PUT'
            }
        });
    }
]);
